import { MoveArrayControlAction } from '../../actions';
import { computeArrayState } from '../../state';
import { childReducer, updateIdRecursive } from './util';
export function move(array, fromIndex, toIndex) {
    const item = array[fromIndex];
    const length = array.length;
    if (fromIndex > toIndex) {
        return [
            ...array.slice(0, toIndex),
            item,
            ...array.slice(toIndex, fromIndex),
            ...array.slice(fromIndex + 1, length),
        ];
    }
    else {
        const targetIndex = toIndex + 1;
        return [
            ...array.slice(0, fromIndex),
            ...array.slice(fromIndex + 1, targetIndex),
            item,
            ...array.slice(targetIndex, length),
        ];
    }
}
export function moveControlReducer(state, action) {
    if (action.type !== MoveArrayControlAction.TYPE) {
        return state;
    }
    if (action.controlId !== state.id) {
        return childReducer(state, action);
    }
    const fromIndex = action.fromIndex;
    const toIndex = action.toIndex;
    if (fromIndex === toIndex) {
        return state;
    }
    if (fromIndex < 0 || toIndex < 0) {
        throw new Error(`fromIndex ${fromIndex} or toIndex ${fromIndex} was negative`);
    }
    if (fromIndex >= state.controls.length || toIndex >= state.controls.length) {
        throw new Error(`fromIndex ${fromIndex} or toIndex ${toIndex} is out of bounds with the length of the controls ${state.controls.length}`);
    }
    let controls = move(state.controls, fromIndex, toIndex);
    controls = controls.map((c, i) => updateIdRecursive(c, `${state.id}.${i}`));
    return computeArrayState(state.id, controls, state.value, state.errors, state.pendingValidations, state.userDefinedProperties, {
        wasOrShouldBeDirty: true,
        wasOrShouldBeEnabled: state.isEnabled,
        wasOrShouldBeTouched: state.isTouched,
        wasOrShouldBeSubmitted: state.isSubmitted,
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW92ZS1jb250cm9sLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vc3JjL2FycmF5L3JlZHVjZXIvbW92ZS1jb250cm9sLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBVyxzQkFBc0IsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNoRSxPQUFPLEVBQUUsaUJBQWlCLEVBQWtCLE1BQU0sYUFBYSxDQUFDO0FBQ2hFLE9BQU8sRUFBRSxZQUFZLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxRQUFRLENBQUM7QUFFekQsTUFBTSxVQUFVLElBQUksQ0FBQyxLQUFxQixFQUFFLFNBQWlCLEVBQUUsT0FBZTtJQUM1RSxNQUFNLElBQUksR0FBRyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDOUIsTUFBTSxNQUFNLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQztJQUM1QixJQUFJLFNBQVMsR0FBRyxPQUFPLEVBQUU7UUFDdkIsT0FBTztZQUNMLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDO1lBQzFCLElBQUk7WUFDSixHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLFNBQVMsQ0FBQztZQUNsQyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsU0FBUyxHQUFHLENBQUMsRUFBRSxNQUFNLENBQUM7U0FDdEMsQ0FBQztLQUNIO1NBQU07UUFDTCxNQUFNLFdBQVcsR0FBRyxPQUFPLEdBQUcsQ0FBQyxDQUFDO1FBQ2hDLE9BQU87WUFDTCxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQztZQUM1QixHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsU0FBUyxHQUFHLENBQUMsRUFBRSxXQUFXLENBQUM7WUFDMUMsSUFBSTtZQUNKLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxXQUFXLEVBQUUsTUFBTSxDQUFDO1NBQ3BDLENBQUM7S0FDSDtBQUNILENBQUM7QUFFRCxNQUFNLFVBQVUsa0JBQWtCLENBQ2hDLEtBQTZCLEVBQzdCLE1BQXlCO0lBRXpCLElBQUksTUFBTSxDQUFDLElBQUksS0FBSyxzQkFBc0IsQ0FBQyxJQUFJLEVBQUU7UUFDL0MsT0FBTyxLQUFLLENBQUM7S0FDZDtJQUNELElBQUksTUFBTSxDQUFDLFNBQVMsS0FBSyxLQUFLLENBQUMsRUFBRSxFQUFFO1FBQ2pDLE9BQU8sWUFBWSxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQztLQUNwQztJQUVELE1BQU0sU0FBUyxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUM7SUFDbkMsTUFBTSxPQUFPLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQztJQUUvQixJQUFJLFNBQVMsS0FBSyxPQUFPLEVBQUU7UUFDekIsT0FBTyxLQUFLLENBQUM7S0FDZDtJQUVELElBQUksU0FBUyxHQUFHLENBQUMsSUFBSSxPQUFPLEdBQUcsQ0FBQyxFQUFFO1FBQ2hDLE1BQU0sSUFBSSxLQUFLLENBQUMsYUFBYSxTQUFTLGVBQWUsU0FBUyxlQUFlLENBQUMsQ0FBQztLQUNoRjtJQUVELElBQUksU0FBUyxJQUFJLEtBQUssQ0FBQyxRQUFRLENBQUMsTUFBTSxJQUFJLE9BQU8sSUFBSSxLQUFLLENBQUMsUUFBUSxDQUFDLE1BQU0sRUFBRTtRQUMxRSxNQUFNLElBQUksS0FBSyxDQUFDLGFBQWEsU0FBUyxlQUFlLE9BQU8scURBQXFELEtBQUssQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQztLQUMzSTtJQUVELElBQUksUUFBUSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUV4RCxRQUFRLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLGlCQUFpQixDQUFNLENBQUMsRUFBRSxHQUFHLEtBQUssQ0FBQyxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBRWpGLE9BQU8saUJBQWlCLENBQ3RCLEtBQUssQ0FBQyxFQUFFLEVBQ1IsUUFBUSxFQUNSLEtBQUssQ0FBQyxLQUFLLEVBQ1gsS0FBSyxDQUFDLE1BQU0sRUFDWixLQUFLLENBQUMsa0JBQWtCLEVBQ3hCLEtBQUssQ0FBQyxxQkFBcUIsRUFDM0I7UUFDRSxrQkFBa0IsRUFBRSxJQUFJO1FBQ3hCLG9CQUFvQixFQUFFLEtBQUssQ0FBQyxTQUFTO1FBQ3JDLG9CQUFvQixFQUFFLEtBQUssQ0FBQyxTQUFTO1FBQ3JDLHNCQUFzQixFQUFFLEtBQUssQ0FBQyxXQUFXO0tBQzFDLENBQ0YsQ0FBQztBQUNKLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBY3Rpb25zLCBNb3ZlQXJyYXlDb250cm9sQWN0aW9uIH0gZnJvbSAnLi4vLi4vYWN0aW9ucyc7XHJcbmltcG9ydCB7IGNvbXB1dGVBcnJheVN0YXRlLCBGb3JtQXJyYXlTdGF0ZSB9IGZyb20gJy4uLy4uL3N0YXRlJztcclxuaW1wb3J0IHsgY2hpbGRSZWR1Y2VyLCB1cGRhdGVJZFJlY3Vyc2l2ZSB9IGZyb20gJy4vdXRpbCc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbW92ZShhcnJheTogcmVhZG9ubHkgYW55W10sIGZyb21JbmRleDogbnVtYmVyLCB0b0luZGV4OiBudW1iZXIpIHtcclxuICBjb25zdCBpdGVtID0gYXJyYXlbZnJvbUluZGV4XTtcclxuICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XHJcbiAgaWYgKGZyb21JbmRleCA+IHRvSW5kZXgpIHtcclxuICAgIHJldHVybiBbXHJcbiAgICAgIC4uLmFycmF5LnNsaWNlKDAsIHRvSW5kZXgpLFxyXG4gICAgICBpdGVtLFxyXG4gICAgICAuLi5hcnJheS5zbGljZSh0b0luZGV4LCBmcm9tSW5kZXgpLFxyXG4gICAgICAuLi5hcnJheS5zbGljZShmcm9tSW5kZXggKyAxLCBsZW5ndGgpLFxyXG4gICAgXTtcclxuICB9IGVsc2Uge1xyXG4gICAgY29uc3QgdGFyZ2V0SW5kZXggPSB0b0luZGV4ICsgMTtcclxuICAgIHJldHVybiBbXHJcbiAgICAgIC4uLmFycmF5LnNsaWNlKDAsIGZyb21JbmRleCksXHJcbiAgICAgIC4uLmFycmF5LnNsaWNlKGZyb21JbmRleCArIDEsIHRhcmdldEluZGV4KSxcclxuICAgICAgaXRlbSxcclxuICAgICAgLi4uYXJyYXkuc2xpY2UodGFyZ2V0SW5kZXgsIGxlbmd0aCksXHJcbiAgICBdO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG1vdmVDb250cm9sUmVkdWNlcjxUVmFsdWU+KFxyXG4gIHN0YXRlOiBGb3JtQXJyYXlTdGF0ZTxUVmFsdWU+LFxyXG4gIGFjdGlvbjogQWN0aW9uczxUVmFsdWVbXT4sXHJcbik6IEZvcm1BcnJheVN0YXRlPFRWYWx1ZT4ge1xyXG4gIGlmIChhY3Rpb24udHlwZSAhPT0gTW92ZUFycmF5Q29udHJvbEFjdGlvbi5UWVBFKSB7XHJcbiAgICByZXR1cm4gc3RhdGU7XHJcbiAgfVxyXG4gIGlmIChhY3Rpb24uY29udHJvbElkICE9PSBzdGF0ZS5pZCkge1xyXG4gICAgcmV0dXJuIGNoaWxkUmVkdWNlcihzdGF0ZSwgYWN0aW9uKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IGZyb21JbmRleCA9IGFjdGlvbi5mcm9tSW5kZXg7XHJcbiAgY29uc3QgdG9JbmRleCA9IGFjdGlvbi50b0luZGV4O1xyXG5cclxuICBpZiAoZnJvbUluZGV4ID09PSB0b0luZGV4KSB7XHJcbiAgICByZXR1cm4gc3RhdGU7XHJcbiAgfVxyXG5cclxuICBpZiAoZnJvbUluZGV4IDwgMCB8fCB0b0luZGV4IDwgMCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBmcm9tSW5kZXggJHtmcm9tSW5kZXh9IG9yIHRvSW5kZXggJHtmcm9tSW5kZXh9IHdhcyBuZWdhdGl2ZWApO1xyXG4gIH1cclxuXHJcbiAgaWYgKGZyb21JbmRleCA+PSBzdGF0ZS5jb250cm9scy5sZW5ndGggfHwgdG9JbmRleCA+PSBzdGF0ZS5jb250cm9scy5sZW5ndGgpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihgZnJvbUluZGV4ICR7ZnJvbUluZGV4fSBvciB0b0luZGV4ICR7dG9JbmRleH0gaXMgb3V0IG9mIGJvdW5kcyB3aXRoIHRoZSBsZW5ndGggb2YgdGhlIGNvbnRyb2xzICR7c3RhdGUuY29udHJvbHMubGVuZ3RofWApO1xyXG4gIH1cclxuXHJcbiAgbGV0IGNvbnRyb2xzID0gbW92ZShzdGF0ZS5jb250cm9scywgZnJvbUluZGV4LCB0b0luZGV4KTtcclxuXHJcbiAgY29udHJvbHMgPSBjb250cm9scy5tYXAoKGMsIGkpID0+IHVwZGF0ZUlkUmVjdXJzaXZlPGFueT4oYywgYCR7c3RhdGUuaWR9LiR7aX1gKSk7XHJcblxyXG4gIHJldHVybiBjb21wdXRlQXJyYXlTdGF0ZShcclxuICAgIHN0YXRlLmlkLFxyXG4gICAgY29udHJvbHMsXHJcbiAgICBzdGF0ZS52YWx1ZSxcclxuICAgIHN0YXRlLmVycm9ycyxcclxuICAgIHN0YXRlLnBlbmRpbmdWYWxpZGF0aW9ucyxcclxuICAgIHN0YXRlLnVzZXJEZWZpbmVkUHJvcGVydGllcyxcclxuICAgIHtcclxuICAgICAgd2FzT3JTaG91bGRCZURpcnR5OiB0cnVlLFxyXG4gICAgICB3YXNPclNob3VsZEJlRW5hYmxlZDogc3RhdGUuaXNFbmFibGVkLFxyXG4gICAgICB3YXNPclNob3VsZEJlVG91Y2hlZDogc3RhdGUuaXNUb3VjaGVkLFxyXG4gICAgICB3YXNPclNob3VsZEJlU3VibWl0dGVkOiBzdGF0ZS5pc1N1Ym1pdHRlZCxcclxuICAgIH1cclxuICApO1xyXG59XHJcbiJdfQ==