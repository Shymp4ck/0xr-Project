import { unbox } from 'ngrx-forms';
// this regex is taken from the @angular/forms source code
// tslint:disable-next-line:max-line-length
export const NGRX_FORMS_EMAIL_VALIDATION_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+(\.[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/;
/**
 * A validation function that requires a value to be a valid e-mail address.
 * Considers `null`, `undefined`, and `''` as valid. Combine this function with the
 * `required` validation function if these values should be considered invalid.
 *
 * The validation error returned by this validation function has the following shape:
 *
```typescript
{
  email: {
    pattern: string;
    actual: string;
  };
}
```
 *
 * Usually you would use this validation function in conjunction with the `validate`
 * update function to perform synchronous validation in your reducer:
 *
```typescript
updateGroup<MyFormValue>({
  userMailAddress: validate(email),
})
```
 *
 * Note that this function is generic to allow the compiler to properly infer the type
 * of the `validate` function for both optional and non-optional controls.
 */
export function email(value) {
    value = unbox(value);
    if (value === null || value === undefined || value.length === 0) {
        return {};
    }
    if (NGRX_FORMS_EMAIL_VALIDATION_REGEXP.test(value)) {
        return {};
    }
    return {
        email: {
            pattern: NGRX_FORMS_EMAIL_VALIDATION_REGEXP.toString(),
            actual: value,
        },
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW1haWwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi92YWxpZGF0aW9uL3NyYy9lbWFpbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQVMsS0FBSyxFQUFvQixNQUFNLFlBQVksQ0FBQztBQUU1RCwwREFBMEQ7QUFDMUQsMkNBQTJDO0FBQzNDLE1BQU0sQ0FBQyxNQUFNLGtDQUFrQyxHQUFHLDRMQUE0TCxDQUFDO0FBYy9POzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0EyQkc7QUFDSCxNQUFNLFVBQVUsS0FBSyxDQUFzRCxLQUFRO0lBQ2pGLEtBQUssR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFtQyxDQUFDO0lBRXZELElBQUksS0FBSyxLQUFLLElBQUksSUFBSSxLQUFLLEtBQUssU0FBUyxJQUFLLEtBQWdCLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtRQUMzRSxPQUFPLEVBQUUsQ0FBQztLQUNYO0lBRUQsSUFBSSxrQ0FBa0MsQ0FBQyxJQUFJLENBQUMsS0FBZSxDQUFDLEVBQUU7UUFDNUQsT0FBTyxFQUFFLENBQUM7S0FDWDtJQUVELE9BQU87UUFDTCxLQUFLLEVBQUU7WUFDTCxPQUFPLEVBQUUsa0NBQWtDLENBQUMsUUFBUSxFQUFFO1lBQ3RELE1BQU0sRUFBRSxLQUFlO1NBQ3hCO0tBQ0YsQ0FBQztBQUNKLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCb3hlZCwgdW5ib3gsIFZhbGlkYXRpb25FcnJvcnMgfSBmcm9tICduZ3J4LWZvcm1zJztcclxuXHJcbi8vIHRoaXMgcmVnZXggaXMgdGFrZW4gZnJvbSB0aGUgQGFuZ3VsYXIvZm9ybXMgc291cmNlIGNvZGVcclxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm1heC1saW5lLWxlbmd0aFxyXG5leHBvcnQgY29uc3QgTkdSWF9GT1JNU19FTUFJTF9WQUxJREFUSU9OX1JFR0VYUCA9IC9eKD89LnsxLDI1NH0kKSg/PS57MSw2NH1AKVstISMkJSYnKisvMC05PT9BLVpeX2BhLXp7fH1+XSsoXFwuWy0hIyQlJicqKy8wLTk9P0EtWl5fYGEtent8fX5dKykqQFtBLVphLXowLTldKFtBLVphLXowLTktXXswLDYxfVtBLVphLXowLTldKT8oXFwuW0EtWmEtejAtOV0oW0EtWmEtejAtOS1dezAsNjF9W0EtWmEtejAtOV0pPykqJC87XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEVtYWlsVmFsaWRhdGlvbkVycm9yIHtcclxuICBwYXR0ZXJuOiBzdHJpbmc7XHJcbiAgYWN0dWFsOiBzdHJpbmc7XHJcbn1cclxuXHJcbi8vIEB0cy1pZ25vcmVcclxuZGVjbGFyZSBtb2R1bGUgJ25ncngtZm9ybXMnIHtcclxuICBleHBvcnQgaW50ZXJmYWNlIFZhbGlkYXRpb25FcnJvcnMge1xyXG4gICAgZW1haWw/OiBFbWFpbFZhbGlkYXRpb25FcnJvcjtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBIHZhbGlkYXRpb24gZnVuY3Rpb24gdGhhdCByZXF1aXJlcyBhIHZhbHVlIHRvIGJlIGEgdmFsaWQgZS1tYWlsIGFkZHJlc3MuXHJcbiAqIENvbnNpZGVycyBgbnVsbGAsIGB1bmRlZmluZWRgLCBhbmQgYCcnYCBhcyB2YWxpZC4gQ29tYmluZSB0aGlzIGZ1bmN0aW9uIHdpdGggdGhlXHJcbiAqIGByZXF1aXJlZGAgdmFsaWRhdGlvbiBmdW5jdGlvbiBpZiB0aGVzZSB2YWx1ZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWQgaW52YWxpZC5cclxuICpcclxuICogVGhlIHZhbGlkYXRpb24gZXJyb3IgcmV0dXJuZWQgYnkgdGhpcyB2YWxpZGF0aW9uIGZ1bmN0aW9uIGhhcyB0aGUgZm9sbG93aW5nIHNoYXBlOlxyXG4gKlxyXG5gYGB0eXBlc2NyaXB0XHJcbntcclxuICBlbWFpbDoge1xyXG4gICAgcGF0dGVybjogc3RyaW5nO1xyXG4gICAgYWN0dWFsOiBzdHJpbmc7XHJcbiAgfTtcclxufVxyXG5gYGBcclxuICpcclxuICogVXN1YWxseSB5b3Ugd291bGQgdXNlIHRoaXMgdmFsaWRhdGlvbiBmdW5jdGlvbiBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBgdmFsaWRhdGVgXHJcbiAqIHVwZGF0ZSBmdW5jdGlvbiB0byBwZXJmb3JtIHN5bmNocm9ub3VzIHZhbGlkYXRpb24gaW4geW91ciByZWR1Y2VyOlxyXG4gKlxyXG5gYGB0eXBlc2NyaXB0XHJcbnVwZGF0ZUdyb3VwPE15Rm9ybVZhbHVlPih7XHJcbiAgdXNlck1haWxBZGRyZXNzOiB2YWxpZGF0ZShlbWFpbCksXHJcbn0pXHJcbmBgYFxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBpcyBnZW5lcmljIHRvIGFsbG93IHRoZSBjb21waWxlciB0byBwcm9wZXJseSBpbmZlciB0aGUgdHlwZVxyXG4gKiBvZiB0aGUgYHZhbGlkYXRlYCBmdW5jdGlvbiBmb3IgYm90aCBvcHRpb25hbCBhbmQgbm9uLW9wdGlvbmFsIGNvbnRyb2xzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGVtYWlsPFQgZXh0ZW5kcyBzdHJpbmcgfCBCb3hlZDxzdHJpbmc+IHwgbnVsbCB8IHVuZGVmaW5lZD4odmFsdWU6IFQpOiBWYWxpZGF0aW9uRXJyb3JzIHtcclxuICB2YWx1ZSA9IHVuYm94KHZhbHVlKSBhcyBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkIGFzIFQ7XHJcblxyXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICh2YWx1ZSBhcyBzdHJpbmcpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgcmV0dXJuIHt9O1xyXG4gIH1cclxuXHJcbiAgaWYgKE5HUlhfRk9STVNfRU1BSUxfVkFMSURBVElPTl9SRUdFWFAudGVzdCh2YWx1ZSBhcyBzdHJpbmcpKSB7XHJcbiAgICByZXR1cm4ge307XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgZW1haWw6IHtcclxuICAgICAgcGF0dGVybjogTkdSWF9GT1JNU19FTUFJTF9WQUxJREFUSU9OX1JFR0VYUC50b1N0cmluZygpLFxyXG4gICAgICBhY3R1YWw6IHZhbHVlIGFzIHN0cmluZyxcclxuICAgIH0sXHJcbiAgfTtcclxufVxyXG4iXX0=