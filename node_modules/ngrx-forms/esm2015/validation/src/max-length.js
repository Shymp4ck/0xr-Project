import { unbox } from 'ngrx-forms';
/**
 * A validation function that requires a `string` or `array` value to have a maximum length.
 * Considers `null` and `undefined` as valid. Combine this function with the `required`
 * validation function if `null` or `undefined` should be considered invalid.
 *
 * The validation error returned by this validation function has the following shape:
 *
```typescript
{
  maxLength: {
    maxLength: number;
    value: string;
    actualLength: number;
  };
}
```
 *
 * Usually you would use this validation function in conjunction with the `validate`
 * update function to perform synchronous validation in your reducer:
 *
```typescript
updateGroup<MyFormValue>({
  name: validate(maxLength(10)),
})
```
 *
 * Note that this function is generic to allow the compiler to properly infer the type
 * of the `validate` function for both optional and non-optional controls.
 */
export function maxLength(maxLengthParam) {
    // tslint:disable-next-line:strict-type-predicates (guard for users without strict type checking)
    if (maxLengthParam === null || maxLengthParam === undefined) {
        throw new Error(`The maxLength Validation function requires the maxLength parameter to be a non-null number, got ${maxLengthParam}!`);
    }
    return (value) => {
        value = unbox(value);
        if (value === null || value === undefined) {
            return {};
        }
        const length = value.length;
        if (length <= maxLengthParam) {
            return {};
        }
        return {
            maxLength: {
                maxLength: maxLengthParam,
                value: value,
                actualLength: length,
            },
        };
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF4LWxlbmd0aC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3ZhbGlkYXRpb24vc3JjL21heC1sZW5ndGgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFTLEtBQUssRUFBb0IsTUFBTSxZQUFZLENBQUM7QUFlNUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0E0Qkc7QUFDSCxNQUFNLFVBQVUsU0FBUyxDQUFDLGNBQXNCO0lBQzlDLGlHQUFpRztJQUNqRyxJQUFJLGNBQWMsS0FBSyxJQUFJLElBQUksY0FBYyxLQUFLLFNBQVMsRUFBRTtRQUMzRCxNQUFNLElBQUksS0FBSyxDQUFDLG1HQUFtRyxjQUFjLEdBQUcsQ0FBQyxDQUFDO0tBQ3ZJO0lBRUQsT0FBTyxDQUE2RSxLQUFRLEVBQW9CLEVBQUU7UUFDaEgsS0FBSyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUVyQixJQUFJLEtBQUssS0FBSyxJQUFJLElBQUksS0FBSyxLQUFLLFNBQVMsRUFBRTtZQUN6QyxPQUFPLEVBQUUsQ0FBQztTQUNYO1FBRUQsTUFBTSxNQUFNLEdBQUksS0FBd0IsQ0FBQyxNQUFNLENBQUM7UUFFaEQsSUFBSSxNQUFNLElBQUksY0FBYyxFQUFFO1lBQzVCLE9BQU8sRUFBRSxDQUFDO1NBQ1g7UUFFRCxPQUFPO1lBQ0wsU0FBUyxFQUFFO2dCQUNULFNBQVMsRUFBRSxjQUFjO2dCQUN6QixLQUFLLEVBQUUsS0FBZTtnQkFDdEIsWUFBWSxFQUFFLE1BQU07YUFDckI7U0FDRixDQUFDO0lBQ0osQ0FBQyxDQUFDO0FBQ0osQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJveGVkLCB1bmJveCwgVmFsaWRhdGlvbkVycm9ycyB9IGZyb20gJ25ncngtZm9ybXMnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBNYXhMZW5ndGhWYWxpZGF0aW9uRXJyb3Ige1xyXG4gIG1heExlbmd0aDogbnVtYmVyO1xyXG4gIHZhbHVlOiBzdHJpbmcgfCBhbnlbXTtcclxuICBhY3R1YWxMZW5ndGg6IG51bWJlcjtcclxufVxyXG5cclxuLy8gQHRzLWlnbm9yZVxyXG5kZWNsYXJlIG1vZHVsZSAnbmdyeC1mb3Jtcycge1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgVmFsaWRhdGlvbkVycm9ycyB7XHJcbiAgICBtYXhMZW5ndGg/OiBNYXhMZW5ndGhWYWxpZGF0aW9uRXJyb3I7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQSB2YWxpZGF0aW9uIGZ1bmN0aW9uIHRoYXQgcmVxdWlyZXMgYSBgc3RyaW5nYCBvciBgYXJyYXlgIHZhbHVlIHRvIGhhdmUgYSBtYXhpbXVtIGxlbmd0aC5cclxuICogQ29uc2lkZXJzIGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgYXMgdmFsaWQuIENvbWJpbmUgdGhpcyBmdW5jdGlvbiB3aXRoIHRoZSBgcmVxdWlyZWRgXHJcbiAqIHZhbGlkYXRpb24gZnVuY3Rpb24gaWYgYG51bGxgIG9yIGB1bmRlZmluZWRgIHNob3VsZCBiZSBjb25zaWRlcmVkIGludmFsaWQuXHJcbiAqXHJcbiAqIFRoZSB2YWxpZGF0aW9uIGVycm9yIHJldHVybmVkIGJ5IHRoaXMgdmFsaWRhdGlvbiBmdW5jdGlvbiBoYXMgdGhlIGZvbGxvd2luZyBzaGFwZTpcclxuICpcclxuYGBgdHlwZXNjcmlwdFxyXG57XHJcbiAgbWF4TGVuZ3RoOiB7XHJcbiAgICBtYXhMZW5ndGg6IG51bWJlcjtcclxuICAgIHZhbHVlOiBzdHJpbmc7XHJcbiAgICBhY3R1YWxMZW5ndGg6IG51bWJlcjtcclxuICB9O1xyXG59XHJcbmBgYFxyXG4gKlxyXG4gKiBVc3VhbGx5IHlvdSB3b3VsZCB1c2UgdGhpcyB2YWxpZGF0aW9uIGZ1bmN0aW9uIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIGB2YWxpZGF0ZWBcclxuICogdXBkYXRlIGZ1bmN0aW9uIHRvIHBlcmZvcm0gc3luY2hyb25vdXMgdmFsaWRhdGlvbiBpbiB5b3VyIHJlZHVjZXI6XHJcbiAqXHJcbmBgYHR5cGVzY3JpcHRcclxudXBkYXRlR3JvdXA8TXlGb3JtVmFsdWU+KHtcclxuICBuYW1lOiB2YWxpZGF0ZShtYXhMZW5ndGgoMTApKSxcclxufSlcclxuYGBgXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGlzIGdlbmVyaWMgdG8gYWxsb3cgdGhlIGNvbXBpbGVyIHRvIHByb3Blcmx5IGluZmVyIHRoZSB0eXBlXHJcbiAqIG9mIHRoZSBgdmFsaWRhdGVgIGZ1bmN0aW9uIGZvciBib3RoIG9wdGlvbmFsIGFuZCBub24tb3B0aW9uYWwgY29udHJvbHMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbWF4TGVuZ3RoKG1heExlbmd0aFBhcmFtOiBudW1iZXIpIHtcclxuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6c3RyaWN0LXR5cGUtcHJlZGljYXRlcyAoZ3VhcmQgZm9yIHVzZXJzIHdpdGhvdXQgc3RyaWN0IHR5cGUgY2hlY2tpbmcpXHJcbiAgaWYgKG1heExlbmd0aFBhcmFtID09PSBudWxsIHx8IG1heExlbmd0aFBhcmFtID09PSB1bmRlZmluZWQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIG1heExlbmd0aCBWYWxpZGF0aW9uIGZ1bmN0aW9uIHJlcXVpcmVzIHRoZSBtYXhMZW5ndGggcGFyYW1ldGVyIHRvIGJlIGEgbm9uLW51bGwgbnVtYmVyLCBnb3QgJHttYXhMZW5ndGhQYXJhbX0hYCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gPFQgZXh0ZW5kcyBzdHJpbmcgfCBCb3hlZDxzdHJpbmc+IHwgYW55W10gfCBCb3hlZDxhbnlbXT4gfCBudWxsIHwgdW5kZWZpbmVkPih2YWx1ZTogVCk6IFZhbGlkYXRpb25FcnJvcnMgPT4ge1xyXG4gICAgdmFsdWUgPSB1bmJveCh2YWx1ZSk7XHJcblxyXG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmV0dXJuIHt9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGxlbmd0aCA9ICh2YWx1ZSBhcyBzdHJpbmcgfCBhbnlbXSkubGVuZ3RoO1xyXG5cclxuICAgIGlmIChsZW5ndGggPD0gbWF4TGVuZ3RoUGFyYW0pIHtcclxuICAgICAgcmV0dXJuIHt9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIG1heExlbmd0aDoge1xyXG4gICAgICAgIG1heExlbmd0aDogbWF4TGVuZ3RoUGFyYW0sXHJcbiAgICAgICAgdmFsdWU6IHZhbHVlIGFzIHN0cmluZyxcclxuICAgICAgICBhY3R1YWxMZW5ndGg6IGxlbmd0aCxcclxuICAgICAgfSxcclxuICAgIH07XHJcbiAgfTtcclxufVxyXG4iXX0=