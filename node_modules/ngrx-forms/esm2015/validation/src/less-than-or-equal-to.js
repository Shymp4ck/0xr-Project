import { unbox } from 'ngrx-forms';
/**
 * A validation function that requires the value to be less than or equal to a number.
 * Considers `null`, `undefined` and non-numeric values as valid. Combine this function with the `required`
 * validation function if `null` or `undefined` should be considered invalid.
 *
 * The validation error returned by this validation function has the following shape:
 *
```typescript
{
  lessThanOrEqualTo: {
    comparand: number;
    actual: number;
  };
}
```
 *
 * Usually you would use this validation function in conjunction with the `validate`
 * update function to perform synchronous validation in your reducer:
 *
```typescript
updateGroup<MyFormValue>({
  amount: validate(lessThanOrEqualTo(10)),
})
```
 *
 * Note that this function is generic to allow the compiler to properly infer the type
 * of the `validate` function for both optional and non-optional controls.
 */
export function lessThanOrEqualTo(comparand) {
    // tslint:disable-next-line:strict-type-predicates (guard for users without strict type checking)
    if (comparand === null || comparand === undefined) {
        throw new Error(`The lessThanOrEqualTo Validation function requires the comparand parameter to be a non-null number, got ${comparand}!`);
    }
    return (value) => {
        value = unbox(value);
        if (value === null || value === undefined || typeof value !== 'number') {
            return {};
        }
        if (value <= comparand) {
            return {};
        }
        return {
            lessThanOrEqualTo: {
                comparand,
                actual: value,
            },
        };
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGVzcy10aGFuLW9yLWVxdWFsLXRvLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vdmFsaWRhdGlvbi9zcmMvbGVzcy10aGFuLW9yLWVxdWFsLXRvLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBUyxLQUFLLEVBQW9CLE1BQU0sWUFBWSxDQUFDO0FBYzVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0EyQkc7QUFDSCxNQUFNLFVBQVUsaUJBQWlCLENBQUMsU0FBaUI7SUFDakQsaUdBQWlHO0lBQ2pHLElBQUksU0FBUyxLQUFLLElBQUksSUFBSSxTQUFTLEtBQUssU0FBUyxFQUFFO1FBQ2pELE1BQU0sSUFBSSxLQUFLLENBQUMsMkdBQTJHLFNBQVMsR0FBRyxDQUFDLENBQUM7S0FDMUk7SUFFRCxPQUFPLENBQXNELEtBQVEsRUFBb0IsRUFBRTtRQUN6RixLQUFLLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBbUMsQ0FBQztRQUV2RCxJQUFJLEtBQUssS0FBSyxJQUFJLElBQUksS0FBSyxLQUFLLFNBQVMsSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7WUFDdEUsT0FBTyxFQUFFLENBQUM7U0FDWDtRQUVELElBQUksS0FBSyxJQUFJLFNBQVMsRUFBRTtZQUN0QixPQUFPLEVBQUUsQ0FBQztTQUNYO1FBRUQsT0FBTztZQUNMLGlCQUFpQixFQUFFO2dCQUNqQixTQUFTO2dCQUNULE1BQU0sRUFBRSxLQUFlO2FBQ3hCO1NBQ0YsQ0FBQztJQUNKLENBQUMsQ0FBQztBQUNKLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCb3hlZCwgdW5ib3gsIFZhbGlkYXRpb25FcnJvcnMgfSBmcm9tICduZ3J4LWZvcm1zJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTGVzc1RoYW5PckVxdWFsVG9WYWxpZGF0aW9uRXJyb3Ige1xyXG4gIGNvbXBhcmFuZDogbnVtYmVyO1xyXG4gIGFjdHVhbDogbnVtYmVyO1xyXG59XHJcblxyXG4vLyBAdHMtaWdub3JlXHJcbmRlY2xhcmUgbW9kdWxlICduZ3J4LWZvcm1zJyB7XHJcbiAgZXhwb3J0IGludGVyZmFjZSBWYWxpZGF0aW9uRXJyb3JzIHtcclxuICAgIGxlc3NUaGFuT3JFcXVhbFRvPzogTGVzc1RoYW5PckVxdWFsVG9WYWxpZGF0aW9uRXJyb3I7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQSB2YWxpZGF0aW9uIGZ1bmN0aW9uIHRoYXQgcmVxdWlyZXMgdGhlIHZhbHVlIHRvIGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byBhIG51bWJlci5cclxuICogQ29uc2lkZXJzIGBudWxsYCwgYHVuZGVmaW5lZGAgYW5kIG5vbi1udW1lcmljIHZhbHVlcyBhcyB2YWxpZC4gQ29tYmluZSB0aGlzIGZ1bmN0aW9uIHdpdGggdGhlIGByZXF1aXJlZGBcclxuICogdmFsaWRhdGlvbiBmdW5jdGlvbiBpZiBgbnVsbGAgb3IgYHVuZGVmaW5lZGAgc2hvdWxkIGJlIGNvbnNpZGVyZWQgaW52YWxpZC5cclxuICpcclxuICogVGhlIHZhbGlkYXRpb24gZXJyb3IgcmV0dXJuZWQgYnkgdGhpcyB2YWxpZGF0aW9uIGZ1bmN0aW9uIGhhcyB0aGUgZm9sbG93aW5nIHNoYXBlOlxyXG4gKlxyXG5gYGB0eXBlc2NyaXB0XHJcbntcclxuICBsZXNzVGhhbk9yRXF1YWxUbzoge1xyXG4gICAgY29tcGFyYW5kOiBudW1iZXI7XHJcbiAgICBhY3R1YWw6IG51bWJlcjtcclxuICB9O1xyXG59XHJcbmBgYFxyXG4gKlxyXG4gKiBVc3VhbGx5IHlvdSB3b3VsZCB1c2UgdGhpcyB2YWxpZGF0aW9uIGZ1bmN0aW9uIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIGB2YWxpZGF0ZWBcclxuICogdXBkYXRlIGZ1bmN0aW9uIHRvIHBlcmZvcm0gc3luY2hyb25vdXMgdmFsaWRhdGlvbiBpbiB5b3VyIHJlZHVjZXI6XHJcbiAqXHJcbmBgYHR5cGVzY3JpcHRcclxudXBkYXRlR3JvdXA8TXlGb3JtVmFsdWU+KHtcclxuICBhbW91bnQ6IHZhbGlkYXRlKGxlc3NUaGFuT3JFcXVhbFRvKDEwKSksXHJcbn0pXHJcbmBgYFxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBpcyBnZW5lcmljIHRvIGFsbG93IHRoZSBjb21waWxlciB0byBwcm9wZXJseSBpbmZlciB0aGUgdHlwZVxyXG4gKiBvZiB0aGUgYHZhbGlkYXRlYCBmdW5jdGlvbiBmb3IgYm90aCBvcHRpb25hbCBhbmQgbm9uLW9wdGlvbmFsIGNvbnRyb2xzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGxlc3NUaGFuT3JFcXVhbFRvKGNvbXBhcmFuZDogbnVtYmVyKSB7XHJcbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnN0cmljdC10eXBlLXByZWRpY2F0ZXMgKGd1YXJkIGZvciB1c2VycyB3aXRob3V0IHN0cmljdCB0eXBlIGNoZWNraW5nKVxyXG4gIGlmIChjb21wYXJhbmQgPT09IG51bGwgfHwgY29tcGFyYW5kID09PSB1bmRlZmluZWQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGxlc3NUaGFuT3JFcXVhbFRvIFZhbGlkYXRpb24gZnVuY3Rpb24gcmVxdWlyZXMgdGhlIGNvbXBhcmFuZCBwYXJhbWV0ZXIgdG8gYmUgYSBub24tbnVsbCBudW1iZXIsIGdvdCAke2NvbXBhcmFuZH0hYCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gPFQgZXh0ZW5kcyBudW1iZXIgfCBCb3hlZDxudW1iZXI+IHwgbnVsbCB8IHVuZGVmaW5lZD4odmFsdWU6IFQpOiBWYWxpZGF0aW9uRXJyb3JzID0+IHtcclxuICAgIHZhbHVlID0gdW5ib3godmFsdWUpIGFzIG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQgYXMgVDtcclxuXHJcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XHJcbiAgICAgIHJldHVybiB7fTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodmFsdWUgPD0gY29tcGFyYW5kKSB7XHJcbiAgICAgIHJldHVybiB7fTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBsZXNzVGhhbk9yRXF1YWxUbzoge1xyXG4gICAgICAgIGNvbXBhcmFuZCxcclxuICAgICAgICBhY3R1YWw6IHZhbHVlIGFzIG51bWJlcixcclxuICAgICAgfSxcclxuICAgIH07XHJcbiAgfTtcclxufVxyXG4iXX0=