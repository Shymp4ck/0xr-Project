(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('@angular/forms'), require('@ngrx/store')) :
    typeof define === 'function' && define.amd ? define('ngrx-forms', ['exports', '@angular/core', '@angular/common', '@angular/forms', '@ngrx/store'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global["ngrx-forms"] = {}, global.ng.core, global.ng.common, global.ng.forms, global.i1));
})(this, (function (exports, i0, common, forms, i1) { 'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () { return e[k]; }
                    });
                }
            });
        }
        n["default"] = e;
        return Object.freeze(n);
    }

    var i0__namespace = /*#__PURE__*/_interopNamespace(i0);
    var i1__namespace = /*#__PURE__*/_interopNamespace(i1);

    // NOTE: the explicit type declaration for the `TYPE` properties is required
    // for the output declarations to properly use the literal string type instead
    // of just `string`
    var SetValueAction = /** @class */ (function () {
        function SetValueAction(controlId, value) {
            this.controlId = controlId;
            this.value = value;
            this.type = SetValueAction.TYPE;
        }
        return SetValueAction;
    }());
    SetValueAction.TYPE = 'ngrx/forms/SET_VALUE';
    var SetErrorsAction = /** @class */ (function () {
        function SetErrorsAction(controlId, errors) {
            this.controlId = controlId;
            this.errors = errors;
            this.type = SetErrorsAction.TYPE;
        }
        return SetErrorsAction;
    }());
    SetErrorsAction.TYPE = 'ngrx/forms/SET_ERRORS';
    var SetAsyncErrorAction = /** @class */ (function () {
        function SetAsyncErrorAction(controlId, name, value) {
            this.controlId = controlId;
            this.name = name;
            this.value = value;
            this.type = SetAsyncErrorAction.TYPE;
        }
        return SetAsyncErrorAction;
    }());
    SetAsyncErrorAction.TYPE = 'ngrx/forms/SET_ASYNC_ERROR';
    var ClearAsyncErrorAction = /** @class */ (function () {
        function ClearAsyncErrorAction(controlId, name) {
            this.controlId = controlId;
            this.name = name;
            this.type = ClearAsyncErrorAction.TYPE;
        }
        return ClearAsyncErrorAction;
    }());
    ClearAsyncErrorAction.TYPE = 'ngrx/forms/CLEAR_ASYNC_ERROR';
    var StartAsyncValidationAction = /** @class */ (function () {
        function StartAsyncValidationAction(controlId, name) {
            this.controlId = controlId;
            this.name = name;
            this.type = StartAsyncValidationAction.TYPE;
        }
        return StartAsyncValidationAction;
    }());
    StartAsyncValidationAction.TYPE = 'ngrx/forms/START_ASYNC_VALIDATION';
    var MarkAsDirtyAction = /** @class */ (function () {
        function MarkAsDirtyAction(controlId) {
            this.controlId = controlId;
            this.type = MarkAsDirtyAction.TYPE;
        }
        return MarkAsDirtyAction;
    }());
    MarkAsDirtyAction.TYPE = 'ngrx/forms/MARK_AS_DIRTY';
    var MarkAsPristineAction = /** @class */ (function () {
        function MarkAsPristineAction(controlId) {
            this.controlId = controlId;
            this.type = MarkAsPristineAction.TYPE;
        }
        return MarkAsPristineAction;
    }());
    MarkAsPristineAction.TYPE = 'ngrx/forms/MARK_AS_PRISTINE';
    var EnableAction = /** @class */ (function () {
        function EnableAction(controlId) {
            this.controlId = controlId;
            this.type = EnableAction.TYPE;
        }
        return EnableAction;
    }());
    EnableAction.TYPE = 'ngrx/forms/ENABLE';
    var DisableAction = /** @class */ (function () {
        function DisableAction(controlId) {
            this.controlId = controlId;
            this.type = DisableAction.TYPE;
        }
        return DisableAction;
    }());
    DisableAction.TYPE = 'ngrx/forms/DISABLE';
    var MarkAsTouchedAction = /** @class */ (function () {
        function MarkAsTouchedAction(controlId) {
            this.controlId = controlId;
            this.type = MarkAsTouchedAction.TYPE;
        }
        return MarkAsTouchedAction;
    }());
    MarkAsTouchedAction.TYPE = 'ngrx/forms/MARK_AS_TOUCHED';
    var MarkAsUntouchedAction = /** @class */ (function () {
        function MarkAsUntouchedAction(controlId) {
            this.controlId = controlId;
            this.type = MarkAsUntouchedAction.TYPE;
        }
        return MarkAsUntouchedAction;
    }());
    MarkAsUntouchedAction.TYPE = 'ngrx/forms/MARK_AS_UNTOUCHED';
    var FocusAction = /** @class */ (function () {
        function FocusAction(controlId) {
            this.controlId = controlId;
            this.type = FocusAction.TYPE;
        }
        return FocusAction;
    }());
    FocusAction.TYPE = 'ngrx/forms/FOCUS';
    var UnfocusAction = /** @class */ (function () {
        function UnfocusAction(controlId) {
            this.controlId = controlId;
            this.type = UnfocusAction.TYPE;
        }
        return UnfocusAction;
    }());
    UnfocusAction.TYPE = 'ngrx/forms/UNFOCUS';
    var MarkAsSubmittedAction = /** @class */ (function () {
        function MarkAsSubmittedAction(controlId) {
            this.controlId = controlId;
            this.type = MarkAsSubmittedAction.TYPE;
        }
        return MarkAsSubmittedAction;
    }());
    MarkAsSubmittedAction.TYPE = 'ngrx/forms/MARK_AS_SUBMITTED';
    var MarkAsUnsubmittedAction = /** @class */ (function () {
        function MarkAsUnsubmittedAction(controlId) {
            this.controlId = controlId;
            this.type = MarkAsUnsubmittedAction.TYPE;
        }
        return MarkAsUnsubmittedAction;
    }());
    MarkAsUnsubmittedAction.TYPE = 'ngrx/forms/MARK_AS_UNSUBMITTED';
    var AddArrayControlAction = /** @class */ (function () {
        function AddArrayControlAction(controlId, value, index) {
            this.controlId = controlId;
            this.value = value;
            this.index = index;
            this.type = AddArrayControlAction.TYPE;
        }
        return AddArrayControlAction;
    }());
    AddArrayControlAction.TYPE = 'ngrx/forms/ADD_ARRAY_CONTROL';
    var AddGroupControlAction = /** @class */ (function () {
        function AddGroupControlAction(controlId, name, value) {
            this.controlId = controlId;
            this.name = name;
            this.value = value;
            this.type = AddGroupControlAction.TYPE;
        }
        return AddGroupControlAction;
    }());
    AddGroupControlAction.TYPE = 'ngrx/forms/ADD_GROUP_CONTROL';
    var RemoveArrayControlAction = /** @class */ (function () {
        function RemoveArrayControlAction(controlId, index) {
            this.controlId = controlId;
            this.index = index;
            this.type = RemoveArrayControlAction.TYPE;
        }
        return RemoveArrayControlAction;
    }());
    RemoveArrayControlAction.TYPE = 'ngrx/forms/REMOVE_ARRAY_CONTROL';
    var SwapArrayControlAction = /** @class */ (function () {
        function SwapArrayControlAction(controlId, fromIndex, toIndex) {
            this.controlId = controlId;
            this.fromIndex = fromIndex;
            this.toIndex = toIndex;
            this.type = SwapArrayControlAction.TYPE;
        }
        return SwapArrayControlAction;
    }());
    SwapArrayControlAction.TYPE = 'ngrx/forms/SWAP_ARRAY_CONTROL';
    var MoveArrayControlAction = /** @class */ (function () {
        function MoveArrayControlAction(controlId, fromIndex, toIndex) {
            this.controlId = controlId;
            this.fromIndex = fromIndex;
            this.toIndex = toIndex;
            this.type = MoveArrayControlAction.TYPE;
        }
        return MoveArrayControlAction;
    }());
    MoveArrayControlAction.TYPE = 'ngrx/forms/MOVE_ARRAY_CONTROL';
    var RemoveGroupControlAction = /** @class */ (function () {
        function RemoveGroupControlAction(controlId, name) {
            this.controlId = controlId;
            this.name = name;
            this.type = RemoveGroupControlAction.TYPE;
        }
        return RemoveGroupControlAction;
    }());
    RemoveGroupControlAction.TYPE = 'ngrx/forms/REMOVE_CONTROL';
    var SetUserDefinedPropertyAction = /** @class */ (function () {
        function SetUserDefinedPropertyAction(controlId, name, value) {
            this.controlId = controlId;
            this.name = name;
            this.value = value;
            this.type = SetUserDefinedPropertyAction.TYPE;
        }
        return SetUserDefinedPropertyAction;
    }());
    SetUserDefinedPropertyAction.TYPE = 'ngrx/forms/SET_USER_DEFINED_PROPERTY';
    var ResetAction = /** @class */ (function () {
        function ResetAction(controlId) {
            this.controlId = controlId;
            this.type = ResetAction.TYPE;
        }
        return ResetAction;
    }());
    ResetAction.TYPE = 'ngrx/forms/RESET';
    function isNgrxFormsAction(action) {
        return !!action.type && action.type.startsWith('ngrx/forms/');
    }
    var ALL_NGRX_FORMS_ACTION_TYPES = [
        SetValueAction.TYPE,
        SetErrorsAction.TYPE,
        SetAsyncErrorAction.TYPE,
        ClearAsyncErrorAction.TYPE,
        StartAsyncValidationAction.TYPE,
        MarkAsDirtyAction.TYPE,
        MarkAsPristineAction.TYPE,
        EnableAction.TYPE,
        DisableAction.TYPE,
        MarkAsTouchedAction.TYPE,
        MarkAsUntouchedAction.TYPE,
        FocusAction.TYPE,
        UnfocusAction.TYPE,
        MarkAsSubmittedAction.TYPE,
        MarkAsUnsubmittedAction.TYPE,
        AddGroupControlAction.TYPE,
        RemoveGroupControlAction.TYPE,
        AddArrayControlAction.TYPE,
        RemoveArrayControlAction.TYPE,
        SetUserDefinedPropertyAction.TYPE,
        ResetAction.TYPE,
        SwapArrayControlAction.TYPE,
        MoveArrayControlAction.TYPE,
    ];

    function isBoxed(value) {
        return !!value && value.__boxed === '';
    }
    function box(value) {
        return {
            __boxed: '',
            value: value,
        };
    }
    function unbox(value) {
        if (['string', 'boolean', 'number', 'undefined'].indexOf(typeof value) >= 0 || value === null || value === undefined) {
            return value;
        }
        if (isBoxed(value)) {
            return value.value;
        }
        if (Array.isArray(value)) {
            return value.map(unbox);
        }
        return Object.keys(value).reduce(function (a, k) {
            var _a;
            return Object.assign(a, (_a = {}, _a[k] = unbox(value[k]), _a));
        }, {});
    }

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
                if (ar || !(i in from)) {
                    if (!ar)
                        ar = Array.prototype.slice.call(from, 0, i);
                    ar[i] = from[i];
                }
            }
        return to.concat(ar || Array.prototype.slice.call(from));
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }
    function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m")
            throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    }

    function isEmpty(obj) {
        return Object.keys(obj).length === 0;
    }
    var defaultOptions = {
        treatUndefinedAndMissingKeyAsSame: false,
    };
    function deepEquals(_1, _2, options) {
        if (options === void 0) { options = {}; }
        var treatUndefinedAndMissingKeyAsSame = Object.assign({}, defaultOptions, options).treatUndefinedAndMissingKeyAsSame;
        var leftChain = [];
        var rightChain = [];
        function compare2Objects(x, y) {
            var p;
            // remember that NaN === NaN returns false
            // and isNaN(undefined) returns true
            if (isNaN(x) && isNaN(y) && typeof x === 'number' && typeof y === 'number') {
                return true;
            }
            // Compare primitives and functions.
            // Check if both arguments link to the same object.
            // Especially useful on the step where we compare prototypes
            if (x === y) {
                return true;
            }
            // Works in case when functions are created in constructor.
            // Comparing dates is a common scenario. Another built-ins?
            // We can even handle functions passed across iframes
            if ((typeof x === 'function' && typeof y === 'function') ||
                (x instanceof Date && y instanceof Date) ||
                (x instanceof RegExp && y instanceof RegExp) ||
                (x instanceof String && y instanceof String) ||
                (x instanceof Number && y instanceof Number)) {
                return x.toString() === y.toString();
            }
            // At last checking prototypes as good as we can
            if (!(x instanceof Object && y instanceof Object)) {
                return false;
            }
            if (x.isPrototypeOf(y) || y.isPrototypeOf(x)) {
                return false;
            }
            if (x.constructor !== y.constructor) {
                return false;
            }
            // Check for infinitive linking loops
            if (leftChain.indexOf(x) > -1 || rightChain.indexOf(y) > -1) {
                return false;
            }
            // Quick checking of one object being a subset of another.
            for (p in y) {
                if (treatUndefinedAndMissingKeyAsSame && y.hasOwnProperty(p) && !x.hasOwnProperty(p) && y[p] === undefined) {
                    continue;
                }
                if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {
                    return false;
                }
                else if (typeof y[p] !== typeof x[p]) {
                    return false;
                }
            }
            // tslint:disable:forin
            for (p in x) {
                if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {
                    if (!treatUndefinedAndMissingKeyAsSame || !x.hasOwnProperty(p) || y.hasOwnProperty(p) || x[p] !== undefined) {
                        return false;
                    }
                }
                switch (typeof (x[p])) {
                    case 'object':
                    case 'function':
                        leftChain.push(x);
                        rightChain.push(y);
                        if (!compare2Objects(x[p], y[p])) {
                            return false;
                        }
                        leftChain.pop();
                        rightChain.pop();
                        break;
                    default:
                        if (x[p] !== y[p]) {
                            return false;
                        }
                        break;
                }
            }
            return true;
        }
        if (arguments.length <= 1) {
            throw new Error('Need two or more arguments to compare');
        }
        return compare2Objects(_1, _2);
    }

    /**
     * This function determines if a value is a form state.
     */
    function isFormState(state) {
        return !!state && state.hasOwnProperty('id') && state.hasOwnProperty('value') && state.hasOwnProperty('errors');
    }
    /**
     * This function determines if a value is an array state.
     */
    function isArrayState(state) {
        return isFormState(state) && state.hasOwnProperty('controls') && Array.isArray(state.controls);
    }
    /**
     * This function determines if a value is a group state.
     */
    function isGroupState(state) {
        return isFormState(state) && state.hasOwnProperty('controls') && !Array.isArray(state.controls) && typeof state.controls !== 'function';
    }
    function createChildState(id, childValue) {
        if (isBoxed(childValue)) {
            return createFormControlState(id, childValue);
        }
        if (childValue !== null && Array.isArray(childValue)) {
            return createFormArrayState(id, childValue);
        }
        if (childValue !== null && typeof childValue === 'object') {
            return createFormGroupState(id, childValue);
        }
        return createFormControlState(id, childValue);
    }
    function verifyFormControlValueIsValid(value) {
        if (value === null || ['string', 'number', 'boolean', 'undefined'].indexOf(typeof value) >= 0) {
            return value;
        }
        if (!isBoxed(value)) {
            var errorMsg = 'Form control states only support undefined, null, string, number, and boolean values as well as boxed values';
            throw new Error(errorMsg + "; got " + JSON.stringify(value) + " of type " + typeof value); // `;
        }
        if (value.value === null || ['string', 'number', 'boolean', 'undefined'].indexOf(typeof value.value) >= 0) {
            return value;
        }
        var serialized = JSON.stringify(value);
        var deserialized = JSON.parse(serialized);
        if (deepEquals(value, deserialized, { treatUndefinedAndMissingKeyAsSame: true })) {
            return value;
        }
        throw new Error("A form control value must be serializable (i.e. value === JSON.parse(JSON.stringify(value))), got: " + JSON.stringify(value));
    }
    /**
     * This function creates a form control state with an ID and a value.
     */
    function createFormControlState(id, value) {
        return {
            id: id,
            value: verifyFormControlValueIsValid(value),
            errors: {},
            pendingValidations: [],
            isValidationPending: false,
            isValid: true,
            isInvalid: false,
            isEnabled: true,
            isDisabled: false,
            isDirty: false,
            isPristine: true,
            isTouched: false,
            isUntouched: true,
            isSubmitted: false,
            isUnsubmitted: true,
            isFocused: false,
            isUnfocused: true,
            userDefinedProperties: {},
        };
    }
    function getFormGroupValue(controls, originalValue) {
        var hasChanged = Object.keys(originalValue).length !== Object.keys(controls).length;
        var newValue = Object.keys(controls).reduce(function (res, key) {
            var control = controls[key];
            hasChanged = hasChanged || originalValue[key] !== control.value;
            res[key] = control.value;
            return res;
        }, {});
        return hasChanged ? newValue : originalValue;
    }
    function getFormGroupErrors(controls, originalErrors) {
        var hasChanged = false;
        var groupErrors = Object.keys(originalErrors)
            .filter(function (key) { return !key.startsWith('_'); })
            .reduce(function (res, key) {
            var _a;
            return Object.assign(res, (_a = {}, _a[key] = originalErrors[key], _a));
        }, {});
        var newErrors = Object.keys(controls).reduce(function (res, key) {
            var _a;
            var control = controls[key];
            var controlErrors = control.errors;
            if (!isEmpty(controlErrors)) {
                hasChanged = hasChanged || originalErrors["_" + key] !== controlErrors;
                Object.assign(res, (_a = {}, _a["_" + key] = control.errors, _a));
            }
            else {
                hasChanged = hasChanged || originalErrors.hasOwnProperty("_" + key);
            }
            return res;
        }, groupErrors);
        hasChanged = hasChanged || Object.keys(originalErrors).length !== Object.keys(newErrors).length;
        return hasChanged ? newErrors : originalErrors;
    }
    function computeGroupState(id, controls, value, errors, pendingValidations, userDefinedProperties, flags) {
        value = getFormGroupValue(controls, value);
        errors = getFormGroupErrors(controls, errors);
        var isValid = isEmpty(errors);
        var isDirty = flags.wasOrShouldBeDirty || Object.keys(controls).some(function (key) { return controls[key].isDirty; });
        var isEnabled = flags.wasOrShouldBeEnabled || Object.keys(controls).some(function (key) { return controls[key].isEnabled; });
        var isTouched = flags.wasOrShouldBeTouched || Object.keys(controls).some(function (key) { return controls[key].isTouched; });
        var isSubmitted = flags.wasOrShouldBeSubmitted || Object.keys(controls).some(function (key) { return controls[key].isSubmitted; });
        var isValidationPending = pendingValidations.length > 0 || Object.keys(controls).some(function (key) { return controls[key].isValidationPending; });
        return {
            id: id,
            value: value,
            errors: errors,
            pendingValidations: pendingValidations,
            isValidationPending: isValidationPending,
            isValid: isValid,
            isInvalid: !isValid,
            isEnabled: isEnabled,
            isDisabled: !isEnabled,
            isDirty: isDirty,
            isPristine: !isDirty,
            isTouched: isTouched,
            isUntouched: !isTouched,
            isSubmitted: isSubmitted,
            isUnsubmitted: !isSubmitted,
            userDefinedProperties: userDefinedProperties,
            controls: controls,
        };
    }
    /**
     * This function creates a form group state with an ID and a value.
     * From the value the shape of the group state is inferred, i.e.
     * object properties are inferred as form groups, array properties
     * are inferred as form arrays, and primitive properties are inferred
     * as form controls.
     */
    function createFormGroupState(id, initialValue) {
        var controls = Object.keys(initialValue)
            .map(function (key) { return [key, createChildState(id + "." + key, initialValue[key])]; })
            .reduce(function (res, _a) {
            var _b;
            var _c = __read(_a, 2), controlId = _c[0], state = _c[1];
            return Object.assign(res, (_b = {}, _b[controlId] = state, _b));
        }, {});
        return computeGroupState(id, controls, initialValue, {}, [], {}, { wasOrShouldBeEnabled: true });
    }
    function getFormArrayValue(controls, originalValue) {
        var hasChanged = Object.keys(originalValue).length !== Object.keys(controls).length;
        var newValue = controls.map(function (state, i) {
            hasChanged = hasChanged || originalValue[i] !== state.value;
            return state.value;
        });
        return hasChanged ? newValue : originalValue;
    }
    function getFormArrayErrors(controls, originalErrors) {
        var hasChanged = false;
        var groupErrors = Object.keys(originalErrors)
            .filter(function (key) { return !key.startsWith('_'); })
            .reduce(function (res, key) {
            var _a;
            return Object.assign(res, (_a = {}, _a[key] = originalErrors[key], _a));
        }, {});
        var newErrors = controls.reduce(function (res, state, i) {
            var _a;
            var controlErrors = state.errors;
            if (!isEmpty(controlErrors)) {
                hasChanged = hasChanged || originalErrors["_" + i] !== controlErrors;
                Object.assign(res, (_a = {}, _a["_" + i] = controlErrors, _a));
            }
            else {
                hasChanged = hasChanged || originalErrors.hasOwnProperty("_" + i);
            }
            return res;
        }, groupErrors);
        hasChanged = hasChanged || Object.keys(originalErrors).length !== Object.keys(newErrors).length;
        return hasChanged ? newErrors : originalErrors;
    }
    function computeArrayState(id, inferredControls, value, errors, pendingValidations, userDefinedProperties, flags) {
        var controls = inferredControls;
        value = getFormArrayValue(controls, value);
        errors = getFormArrayErrors(controls, errors);
        var isValid = isEmpty(errors);
        var isDirty = flags.wasOrShouldBeDirty || controls.some(function (state) { return state.isDirty; });
        var isEnabled = flags.wasOrShouldBeEnabled || controls.some(function (state) { return state.isEnabled; });
        var isTouched = flags.wasOrShouldBeTouched || controls.some(function (state) { return state.isTouched; });
        var isSubmitted = flags.wasOrShouldBeSubmitted || controls.some(function (state) { return state.isSubmitted; });
        var isValidationPending = pendingValidations.length > 0 || controls.some(function (state) { return state.isValidationPending; });
        return {
            id: id,
            value: value,
            errors: errors,
            pendingValidations: pendingValidations,
            isValidationPending: isValidationPending,
            isValid: isValid,
            isInvalid: !isValid,
            isEnabled: isEnabled,
            isDisabled: !isEnabled,
            isDirty: isDirty,
            isPristine: !isDirty,
            isTouched: isTouched,
            isUntouched: !isTouched,
            isSubmitted: isSubmitted,
            isUnsubmitted: !isSubmitted,
            userDefinedProperties: userDefinedProperties,
            controls: inferredControls,
        };
    }
    /**
     * This function creates a form array state with an ID and a value.
     * From the value the shape of the array state is inferred, i.e.
     * object values are inferred as form groups, array values
     * are inferred as form arrays, and primitive values are inferred
     * as form controls.
     */
    function createFormArrayState(id, initialValue) {
        var controls = initialValue
            .map(function (value, i) { return createChildState(id + "." + i, value); });
        return computeArrayState(id, controls, initialValue, {}, [], {}, { wasOrShouldBeEnabled: true });
    }

    function clearAsyncErrorReducer$2(state, action) {
        if (action.type !== ClearAsyncErrorAction.TYPE) {
            return state;
        }
        var name = "$" + action.name;
        var errors = state.errors;
        if (errors.hasOwnProperty(name)) {
            errors = Object.assign({}, state.errors);
            delete errors[name];
        }
        var pendingValidations = state.pendingValidations.filter(function (v) { return v !== action.name; });
        var isValid = isEmpty(errors);
        if (errors === state.errors && isValid === state.isValid && pendingValidations.length === state.pendingValidations.length) {
            return state;
        }
        return Object.assign(Object.assign({}, state), { isValid: isValid, isInvalid: !isValid, errors: errors,
            pendingValidations: pendingValidations, isValidationPending: pendingValidations.length > 0 });
    }

    function disableReducer$2(state, action) {
        if (action.type !== DisableAction.TYPE) {
            return state;
        }
        if (state.isDisabled) {
            return state;
        }
        return Object.assign(Object.assign({}, state), { isEnabled: false, isDisabled: true, isValid: true, isInvalid: false, errors: {}, pendingValidations: [], isValidationPending: false });
    }

    function enableReducer$2(state, action) {
        if (action.type !== EnableAction.TYPE) {
            return state;
        }
        if (state.isEnabled) {
            return state;
        }
        return Object.assign(Object.assign({}, state), { isEnabled: true, isDisabled: false });
    }

    function focusReducer(state, action) {
        if (action.type !== FocusAction.TYPE) {
            return state;
        }
        if (state.isFocused) {
            return state;
        }
        return Object.assign(Object.assign({}, state), { isFocused: true, isUnfocused: false });
    }

    function markAsDirtyReducer$2(state, action) {
        if (action.type !== MarkAsDirtyAction.TYPE) {
            return state;
        }
        if (state.isDirty) {
            return state;
        }
        return Object.assign(Object.assign({}, state), { isDirty: true, isPristine: false });
    }

    function markAsPristineReducer$2(state, action) {
        if (action.type !== MarkAsPristineAction.TYPE) {
            return state;
        }
        if (state.isPristine) {
            return state;
        }
        return Object.assign(Object.assign({}, state), { isDirty: false, isPristine: true });
    }

    function markAsSubmittedReducer$2(state, action) {
        if (action.type !== MarkAsSubmittedAction.TYPE) {
            return state;
        }
        if (state.isSubmitted) {
            return state;
        }
        return Object.assign(Object.assign({}, state), { isSubmitted: true, isUnsubmitted: false });
    }

    function markAsTouchedReducer$2(state, action) {
        if (action.type !== MarkAsTouchedAction.TYPE) {
            return state;
        }
        if (state.isTouched) {
            return state;
        }
        return Object.assign(Object.assign({}, state), { isTouched: true, isUntouched: false });
    }

    function markAsUnsubmittedReducer$2(state, action) {
        if (action.type !== MarkAsUnsubmittedAction.TYPE) {
            return state;
        }
        if (state.isUnsubmitted) {
            return state;
        }
        return Object.assign(Object.assign({}, state), { isSubmitted: false, isUnsubmitted: true });
    }

    function markAsUntouchedReducer$2(state, action) {
        if (action.type !== MarkAsUntouchedAction.TYPE) {
            return state;
        }
        if (state.isUntouched) {
            return state;
        }
        return Object.assign(Object.assign({}, state), { isTouched: false, isUntouched: true });
    }

    function resetReducer$2(state, action) {
        if (action.type !== ResetAction.TYPE) {
            return state;
        }
        if (state.isPristine && state.isUntouched && state.isUnsubmitted) {
            return state;
        }
        return Object.assign(Object.assign({}, state), { isDirty: false, isPristine: true, isTouched: false, isUntouched: true, isSubmitted: false, isUnsubmitted: true });
    }

    function setAsyncErrorReducer$2(state, action) {
        var _a;
        if (action.type !== SetAsyncErrorAction.TYPE) {
            return state;
        }
        if (state.isDisabled) {
            return state;
        }
        var name = "$" + action.name;
        var value = action.value;
        if (deepEquals(state.errors[name], action.value)) {
            value = state.errors[name];
        }
        var errors = Object.assign(Object.assign({}, state.errors), (_a = {}, _a[name] = value, _a));
        var pendingValidations = state.pendingValidations.filter(function (v) { return v !== action.name; });
        return Object.assign(Object.assign({}, state), { isValid: false, isInvalid: true, errors: errors,
            pendingValidations: pendingValidations, isValidationPending: pendingValidations.length > 0 });
    }

    function setErrorsReducer$2(state, action) {
        if (action.type !== SetErrorsAction.TYPE) {
            return state;
        }
        if (state.isDisabled) {
            return state;
        }
        if (state.errors === action.errors) {
            return state;
        }
        if (deepEquals(state.errors, action.errors)) {
            return state;
        }
        if (!action.errors || typeof action.errors !== 'object' || Array.isArray(action.errors)) {
            throw new Error("Control errors must be an object; got " + action.errors); // `;
        }
        if (Object.keys(action.errors).some(function (key) { return key.startsWith('$'); })) {
            throw new Error("Control errors must not use $ as a prefix; got " + JSON.stringify(action.errors)); // `;
        }
        var asyncErrors = Object.keys(state.errors)
            .filter(function (key) { return key.startsWith('$'); })
            .reduce(function (res, key) {
            var _a;
            return Object.assign(res, (_a = {}, _a[key] = state.errors[key], _a));
        }, {});
        var newErrors = isEmpty(asyncErrors) ? action.errors : Object.assign(asyncErrors, action.errors);
        var isValid = isEmpty(newErrors);
        return Object.assign(Object.assign({}, state), { isValid: isValid, isInvalid: !isValid, errors: newErrors });
    }

    function setUserDefinedPropertyReducer$2(state, action) {
        var _a;
        if (action.type !== SetUserDefinedPropertyAction.TYPE) {
            return state;
        }
        if (state.userDefinedProperties[action.name] === action.value) {
            return state;
        }
        return Object.assign(Object.assign({}, state), { userDefinedProperties: Object.assign(Object.assign({}, state.userDefinedProperties), (_a = {}, _a[action.name] = action.value, _a)) });
    }

    function setValueReducer$2(state, action) {
        if (action.type !== SetValueAction.TYPE) {
            return state;
        }
        if (state.value === action.value) {
            return state;
        }
        return Object.assign(Object.assign({}, state), { value: verifyFormControlValueIsValid(action.value) });
    }

    function startAsyncValidationReducer$2(state, action) {
        if (action.type !== StartAsyncValidationAction.TYPE) {
            return state;
        }
        if (state.pendingValidations.indexOf(action.name) >= 0) {
            return state;
        }
        return Object.assign(Object.assign({}, state), { pendingValidations: __spreadArray(__spreadArray([], __read(state.pendingValidations)), [action.name]), isValidationPending: true });
    }

    function unfocusReducer(state, action) {
        if (action.type !== UnfocusAction.TYPE) {
            return state;
        }
        if (state.isUnfocused) {
            return state;
        }
        return Object.assign(Object.assign({}, state), { isFocused: false, isUnfocused: true });
    }

    function formControlReducerInternal(state, action) {
        if (isGroupState(state) || isArrayState(state)) {
            throw new Error('The state must be a control state');
        }
        if (action.controlId !== state.id) {
            return state;
        }
        state = setValueReducer$2(state, action);
        state = setErrorsReducer$2(state, action);
        state = startAsyncValidationReducer$2(state, action);
        state = setAsyncErrorReducer$2(state, action);
        state = clearAsyncErrorReducer$2(state, action);
        state = enableReducer$2(state, action);
        state = disableReducer$2(state, action);
        state = focusReducer(state, action);
        state = unfocusReducer(state, action);
        state = markAsDirtyReducer$2(state, action);
        state = markAsPristineReducer$2(state, action);
        state = markAsTouchedReducer$2(state, action);
        state = markAsUntouchedReducer$2(state, action);
        state = markAsSubmittedReducer$2(state, action);
        state = markAsUnsubmittedReducer$2(state, action);
        state = setUserDefinedPropertyReducer$2(state, action);
        state = resetReducer$2(state, action);
        return state;
    }
    /**
     * This reducer function updates a form control state with actions.
     */
    function formControlReducer(state, action) {
        if (!state) {
            throw new Error('The control state must be defined!');
        }
        return formControlReducerInternal(state, action);
    }

    function dispatchActionPerChild$1(controls, actionCreator) {
        var hasChanged = false;
        var newControls = controls
            .map(function (state) {
            var newState = formStateReducer(state, actionCreator(state.id));
            hasChanged = hasChanged || state !== newState;
            return newState;
        });
        return hasChanged ? newControls : controls;
    }
    function callChildReducers$1(controls, action) {
        var hasChanged = false;
        var newControls = controls
            .map(function (state) {
            var newState = formStateReducer(state, action);
            hasChanged = hasChanged || state !== newState;
            return newState;
        });
        return hasChanged ? newControls : controls;
    }
    function childReducer$1(state, action) {
        var controls = callChildReducers$1(state.controls, action);
        if (state.controls === controls) {
            return state;
        }
        return computeArrayState(state.id, controls, state.value, state.errors, state.pendingValidations, state.userDefinedProperties, {
            wasOrShouldBeDirty: state.isDirty,
            wasOrShouldBeEnabled: state.isEnabled,
            wasOrShouldBeTouched: state.isTouched,
            wasOrShouldBeSubmitted: state.isSubmitted,
        });
    }
    function updateIdRecursiveForGroup(state, newId) {
        var controls = Object.keys(state.controls)
            .reduce(function (agg, key) {
            var _a;
            return Object.assign(agg, (_a = {},
                _a[key] = updateIdRecursive(state.controls[key], newId + "." + key),
                _a));
        }, {});
        return Object.assign(Object.assign({}, state), { id: newId, controls: controls });
    }
    function updateIdRecursiveForArray(state, newId) {
        var controls = state.controls.map(function (c, i) { return updateIdRecursive(c, newId + "." + i); });
        return Object.assign(Object.assign({}, state), { id: newId, controls: controls });
    }
    function updateIdRecursive(state, newId) {
        if (state.id === newId) {
            return state;
        }
        if (isGroupState(state)) {
            return updateIdRecursiveForGroup(state, newId);
        }
        if (isArrayState(state)) {
            return updateIdRecursiveForArray(state, newId);
        }
        return Object.assign(Object.assign({}, state), { id: newId });
    }

    function addControlReducer$1(state, action) {
        if (action.type !== AddArrayControlAction.TYPE) {
            return state;
        }
        if (action.controlId !== state.id) {
            return childReducer$1(state, action);
        }
        var index = action.index === undefined ? state.controls.length : action.index;
        if (index > state.controls.length || index < 0) {
            throw new Error("Index " + index + " is out of bounds for array '" + state.id + "' with length " + state.controls.length + "!");
        }
        var controls = __spreadArray([], __read(state.controls));
        controls.splice(index, 0, createChildState(state.id + "." + index, action.value));
        controls = controls.map(function (c, i) { return updateIdRecursive(c, state.id + "." + i); });
        return computeArrayState(state.id, controls, state.value, state.errors, state.pendingValidations, state.userDefinedProperties, {
            wasOrShouldBeDirty: true,
            wasOrShouldBeEnabled: state.isEnabled,
            wasOrShouldBeTouched: state.isTouched,
            wasOrShouldBeSubmitted: state.isSubmitted,
        });
    }

    function clearAsyncErrorReducer$1(state, action) {
        if (action.type !== ClearAsyncErrorAction.TYPE) {
            return state;
        }
        if (action.controlId !== state.id) {
            return childReducer$1(state, action);
        }
        var name = "$" + action.name;
        var errors = state.errors;
        if (state.errors.hasOwnProperty(name)) {
            errors = Object.assign({}, state.errors);
            delete errors[name];
        }
        var pendingValidations = state.pendingValidations.filter(function (v) { return v !== action.name; });
        if (errors === state.errors && pendingValidations.length === state.pendingValidations.length) {
            return state;
        }
        return computeArrayState(state.id, state.controls, state.value, errors, pendingValidations, state.userDefinedProperties, {
            wasOrShouldBeDirty: state.isDirty,
            wasOrShouldBeEnabled: state.isEnabled,
            wasOrShouldBeTouched: state.isTouched,
            wasOrShouldBeSubmitted: state.isSubmitted,
        });
    }

    function disableReducer$1(state, action) {
        if (action.type !== DisableAction.TYPE) {
            return state;
        }
        if (action.controlId !== state.id) {
            return childReducer$1(state, action);
        }
        if (state.isDisabled) {
            return state;
        }
        return computeArrayState(state.id, dispatchActionPerChild$1(state.controls, function (controlId) { return new DisableAction(controlId); }), state.value, {}, [], state.userDefinedProperties, {
            wasOrShouldBeDirty: state.isDirty,
            wasOrShouldBeEnabled: false,
            wasOrShouldBeTouched: state.isTouched,
            wasOrShouldBeSubmitted: state.isSubmitted,
        });
    }

    function enableReducer$1(state, action) {
        if (action.type !== EnableAction.TYPE) {
            return state;
        }
        if (action.controlId !== state.id) {
            return childReducer$1(state, action);
        }
        var controls = dispatchActionPerChild$1(state.controls, function (controlId) { return new EnableAction(controlId); });
        if (controls === state.controls && state.isEnabled) {
            return state;
        }
        return computeArrayState(state.id, controls, state.value, state.errors, state.pendingValidations, state.userDefinedProperties, {
            wasOrShouldBeDirty: state.isDirty,
            wasOrShouldBeEnabled: true,
            wasOrShouldBeTouched: state.isTouched,
            wasOrShouldBeSubmitted: state.isSubmitted,
        });
    }

    function markAsDirtyReducer$1(state, action) {
        if (action.type !== MarkAsDirtyAction.TYPE) {
            return state;
        }
        if (action.controlId !== state.id) {
            return childReducer$1(state, action);
        }
        var controls = dispatchActionPerChild$1(state.controls, function (controlId) { return new MarkAsDirtyAction(controlId); });
        if (controls === state.controls && state.isDirty) {
            return state;
        }
        return computeArrayState(state.id, controls, state.value, state.errors, state.pendingValidations, state.userDefinedProperties, {
            wasOrShouldBeDirty: true,
            wasOrShouldBeEnabled: state.isEnabled,
            wasOrShouldBeTouched: state.isTouched,
            wasOrShouldBeSubmitted: state.isSubmitted,
        });
    }

    function markAsPristineReducer$1(state, action) {
        if (action.type !== MarkAsPristineAction.TYPE) {
            return state;
        }
        if (action.controlId !== state.id) {
            return childReducer$1(state, action);
        }
        if (state.isPristine) {
            return state;
        }
        return computeArrayState(state.id, dispatchActionPerChild$1(state.controls, function (controlId) { return new MarkAsPristineAction(controlId); }), state.value, state.errors, state.pendingValidations, state.userDefinedProperties, {
            wasOrShouldBeDirty: false,
            wasOrShouldBeEnabled: state.isEnabled,
            wasOrShouldBeTouched: state.isTouched,
            wasOrShouldBeSubmitted: state.isSubmitted,
        });
    }

    function markAsSubmittedReducer$1(state, action) {
        if (action.type !== MarkAsSubmittedAction.TYPE) {
            return state;
        }
        if (action.controlId !== state.id) {
            return childReducer$1(state, action);
        }
        var controls = dispatchActionPerChild$1(state.controls, function (controlId) { return new MarkAsSubmittedAction(controlId); });
        if (controls === state.controls) {
            return state;
        }
        return computeArrayState(state.id, controls, state.value, state.errors, state.pendingValidations, state.userDefinedProperties, {
            wasOrShouldBeDirty: state.isDirty,
            wasOrShouldBeEnabled: state.isEnabled,
            wasOrShouldBeTouched: state.isTouched,
            wasOrShouldBeSubmitted: true,
        });
    }

    function markAsTouchedReducer$1(state, action) {
        if (action.type !== MarkAsTouchedAction.TYPE) {
            return state;
        }
        if (action.controlId !== state.id) {
            return childReducer$1(state, action);
        }
        var controls = dispatchActionPerChild$1(state.controls, function (controlId) { return new MarkAsTouchedAction(controlId); });
        if (controls === state.controls) {
            return state;
        }
        return computeArrayState(state.id, controls, state.value, state.errors, state.pendingValidations, state.userDefinedProperties, {
            wasOrShouldBeDirty: state.isDirty,
            wasOrShouldBeEnabled: state.isEnabled,
            wasOrShouldBeTouched: true,
            wasOrShouldBeSubmitted: state.isSubmitted,
        });
    }

    function markAsUnsubmittedReducer$1(state, action) {
        if (action.type !== MarkAsUnsubmittedAction.TYPE) {
            return state;
        }
        if (action.controlId !== state.id) {
            return childReducer$1(state, action);
        }
        if (state.isUnsubmitted) {
            return state;
        }
        return computeArrayState(state.id, dispatchActionPerChild$1(state.controls, function (controlId) { return new MarkAsUnsubmittedAction(controlId); }), state.value, state.errors, state.pendingValidations, state.userDefinedProperties, {
            wasOrShouldBeDirty: state.isDirty,
            wasOrShouldBeEnabled: state.isEnabled,
            wasOrShouldBeTouched: state.isTouched,
            wasOrShouldBeSubmitted: false,
        });
    }

    function markAsUntouchedReducer$1(state, action) {
        if (action.type !== MarkAsUntouchedAction.TYPE) {
            return state;
        }
        if (action.controlId !== state.id) {
            return childReducer$1(state, action);
        }
        if (state.isUntouched) {
            return state;
        }
        return computeArrayState(state.id, dispatchActionPerChild$1(state.controls, function (controlId) { return new MarkAsUntouchedAction(controlId); }), state.value, state.errors, state.pendingValidations, state.userDefinedProperties, {
            wasOrShouldBeDirty: state.isDirty,
            wasOrShouldBeEnabled: state.isEnabled,
            wasOrShouldBeTouched: false,
            wasOrShouldBeSubmitted: state.isSubmitted,
        });
    }

    function move(array, fromIndex, toIndex) {
        var item = array[fromIndex];
        var length = array.length;
        if (fromIndex > toIndex) {
            return __spreadArray(__spreadArray(__spreadArray(__spreadArray([], __read(array.slice(0, toIndex))), [
                item
            ]), __read(array.slice(toIndex, fromIndex))), __read(array.slice(fromIndex + 1, length)));
        }
        else {
            var targetIndex = toIndex + 1;
            return __spreadArray(__spreadArray(__spreadArray(__spreadArray([], __read(array.slice(0, fromIndex))), __read(array.slice(fromIndex + 1, targetIndex))), [
                item
            ]), __read(array.slice(targetIndex, length)));
        }
    }
    function moveControlReducer(state, action) {
        if (action.type !== MoveArrayControlAction.TYPE) {
            return state;
        }
        if (action.controlId !== state.id) {
            return childReducer$1(state, action);
        }
        var fromIndex = action.fromIndex;
        var toIndex = action.toIndex;
        if (fromIndex === toIndex) {
            return state;
        }
        if (fromIndex < 0 || toIndex < 0) {
            throw new Error("fromIndex " + fromIndex + " or toIndex " + fromIndex + " was negative");
        }
        if (fromIndex >= state.controls.length || toIndex >= state.controls.length) {
            throw new Error("fromIndex " + fromIndex + " or toIndex " + toIndex + " is out of bounds with the length of the controls " + state.controls.length);
        }
        var controls = move(state.controls, fromIndex, toIndex);
        controls = controls.map(function (c, i) { return updateIdRecursive(c, state.id + "." + i); });
        return computeArrayState(state.id, controls, state.value, state.errors, state.pendingValidations, state.userDefinedProperties, {
            wasOrShouldBeDirty: true,
            wasOrShouldBeEnabled: state.isEnabled,
            wasOrShouldBeTouched: state.isTouched,
            wasOrShouldBeSubmitted: state.isSubmitted,
        });
    }

    function removeControlReducer$1(state, action) {
        if (action.type !== RemoveArrayControlAction.TYPE) {
            return state;
        }
        if (action.controlId !== state.id) {
            return childReducer$1(state, action);
        }
        if (action.index >= state.controls.length || action.index < 0) {
            throw new Error("Index " + action.index + " is out of bounds for array '" + state.id + "' with length " + state.controls.length + "!");
        }
        var index = action.index;
        var controls = state.controls.filter(function (_, i) { return i !== index; }).map(function (c, i) { return updateIdRecursive(c, state.id + "." + i); });
        return computeArrayState(state.id, controls, state.value, state.errors, state.pendingValidations, state.userDefinedProperties, {
            wasOrShouldBeDirty: true,
            wasOrShouldBeEnabled: state.isEnabled,
            wasOrShouldBeTouched: state.isTouched,
            wasOrShouldBeSubmitted: state.isSubmitted,
        });
    }

    function resetReducer$1(state, action) {
        if (action.type !== ResetAction.TYPE) {
            return state;
        }
        if (action.controlId !== state.id) {
            return childReducer$1(state, action);
        }
        if (state.isPristine && state.isUntouched && state.isUnsubmitted) {
            return state;
        }
        return computeArrayState(state.id, dispatchActionPerChild$1(state.controls, function (controlId) { return new ResetAction(controlId); }), state.value, state.errors, state.pendingValidations, state.userDefinedProperties, {
            wasOrShouldBeDirty: false,
            wasOrShouldBeEnabled: state.isEnabled,
            wasOrShouldBeTouched: false,
            wasOrShouldBeSubmitted: false,
        });
    }

    function setAsyncErrorReducer$1(state, action) {
        var _a;
        if (action.type !== SetAsyncErrorAction.TYPE) {
            return state;
        }
        if (action.controlId !== state.id) {
            return childReducer$1(state, action);
        }
        if (state.isDisabled) {
            return state;
        }
        var name = "$" + action.name;
        var value = action.value;
        if (deepEquals(state.errors[name], action.value)) {
            value = state.errors[name];
        }
        var errors = Object.assign(Object.assign({}, state.errors), (_a = {}, _a[name] = value, _a));
        var pendingValidations = state.pendingValidations.filter(function (v) { return v !== action.name; });
        return computeArrayState(state.id, state.controls, state.value, errors, pendingValidations, state.userDefinedProperties, {
            wasOrShouldBeDirty: state.isDirty,
            wasOrShouldBeEnabled: state.isEnabled,
            wasOrShouldBeTouched: state.isTouched,
            wasOrShouldBeSubmitted: state.isSubmitted,
        });
    }

    function setErrorsReducer$1(state, action) {
        if (action.type !== SetErrorsAction.TYPE) {
            return state;
        }
        if (action.controlId !== state.id) {
            return childReducer$1(state, action);
        }
        if (state.isDisabled) {
            return state;
        }
        if (state.errors === action.errors) {
            return state;
        }
        if (deepEquals(state.errors, action.errors)) {
            return state;
        }
        if (!action.errors || typeof action.errors !== 'object' || Array.isArray(action.errors)) {
            throw new Error("Control errors must be an object; got " + action.errors);
        }
        if (Object.keys(action.errors).some(function (key) { return key.startsWith('_'); })) {
            throw new Error("Control errors must not use underscore as a prefix; got " + JSON.stringify(action.errors));
        }
        if (Object.keys(action.errors).some(function (key) { return key.startsWith('$'); })) {
            throw new Error("Control errors must not use $ as a prefix; got " + JSON.stringify(action.errors));
        }
        var childAndAsyncErrors = Object.keys(state.errors)
            .filter(function (key) { return key.startsWith('_') || key.startsWith('$'); })
            .reduce(function (res, key) {
            var _a;
            return Object.assign(res, (_a = {}, _a[key] = state.errors[key], _a));
        }, {});
        var newErrors = Object.assign(childAndAsyncErrors, action.errors);
        return computeArrayState(state.id, state.controls, state.value, newErrors, state.pendingValidations, state.userDefinedProperties, {
            wasOrShouldBeDirty: state.isDirty,
            wasOrShouldBeEnabled: state.isEnabled,
            wasOrShouldBeTouched: state.isTouched,
            wasOrShouldBeSubmitted: state.isSubmitted,
        });
    }

    function setUserDefinedPropertyReducer$1(state, action) {
        var _a;
        if (action.type !== SetUserDefinedPropertyAction.TYPE) {
            return state;
        }
        if (action.controlId !== state.id) {
            return childReducer$1(state, action);
        }
        if (state.userDefinedProperties[action.name] === action.value) {
            return state;
        }
        return Object.assign(Object.assign({}, state), { userDefinedProperties: Object.assign(Object.assign({}, state.userDefinedProperties), (_a = {}, _a[action.name] = action.value, _a)) });
    }

    function setValueReducer$1(state, action) {
        if (action.type !== SetValueAction.TYPE) {
            return state;
        }
        if (action.controlId !== state.id) {
            return childReducer$1(state, action);
        }
        if (state.value === action.value) {
            return state;
        }
        if (action.value instanceof Date) {
            throw new Error('Date values are not supported. Please used serialized strings instead.');
        }
        var value = action.value;
        var controls = value
            .map(function (v, i) {
            if (!state.controls[i]) {
                return createChildState(state.id + "." + i, v);
            }
            return formStateReducer(state.controls[i], new SetValueAction(state.controls[i].id, v));
        });
        return computeArrayState(state.id, controls, value, state.errors, state.pendingValidations, state.userDefinedProperties, {
            wasOrShouldBeDirty: state.isDirty,
            wasOrShouldBeEnabled: state.isEnabled,
            wasOrShouldBeTouched: state.isTouched,
            wasOrShouldBeSubmitted: state.isSubmitted,
        });
    }

    function startAsyncValidationReducer$1(state, action) {
        if (action.type !== StartAsyncValidationAction.TYPE) {
            return state;
        }
        if (action.controlId !== state.id) {
            return childReducer$1(state, action);
        }
        if (state.pendingValidations.indexOf(action.name) >= 0) {
            return state;
        }
        var pendingValidations = __spreadArray(__spreadArray([], __read(state.pendingValidations)), [action.name]);
        return computeArrayState(state.id, state.controls, state.value, state.errors, pendingValidations, state.userDefinedProperties, {
            wasOrShouldBeDirty: state.isDirty,
            wasOrShouldBeEnabled: state.isEnabled,
            wasOrShouldBeTouched: state.isTouched,
            wasOrShouldBeSubmitted: state.isSubmitted,
        });
    }

    function swapArrayValues(a, i, j) {
        var _a;
        var n = __spreadArray([], __read(a));
        _a = __read([n[j], n[i]], 2), n[i] = _a[0], n[j] = _a[1];
        return n;
    }
    function swapControlReducer(state, action) {
        if (action.type !== SwapArrayControlAction.TYPE) {
            return state;
        }
        if (action.controlId !== state.id) {
            return childReducer$1(state, action);
        }
        var fromIndex = action.fromIndex;
        var toIndex = action.toIndex;
        if (fromIndex === toIndex) {
            return state;
        }
        if (fromIndex < 0 || toIndex < 0) {
            throw new Error("fromIndex " + fromIndex + " or toIndex " + fromIndex + " was negative");
        }
        if (fromIndex >= state.controls.length || toIndex >= state.controls.length) {
            throw new Error("fromIndex " + fromIndex + " or toIndex " + toIndex + " is out of bounds with the length of the controls " + state.controls.length);
        }
        var controls = swapArrayValues(state.controls, fromIndex, toIndex);
        controls = controls.map(function (c, i) { return (i >= fromIndex || i >= toIndex) ? updateIdRecursive(c, state.id + "." + i) : c; });
        return computeArrayState(state.id, controls, state.value, state.errors, state.pendingValidations, state.userDefinedProperties, {
            wasOrShouldBeDirty: true,
            wasOrShouldBeEnabled: state.isEnabled,
            wasOrShouldBeTouched: state.isTouched,
            wasOrShouldBeSubmitted: state.isSubmitted,
        });
    }

    function formArrayReducerInternal(state, action) {
        if (!isArrayState(state)) {
            throw new Error('The state must be an array state');
        }
        if (!isNgrxFormsAction(action)) {
            return state;
        }
        if (!action.controlId.startsWith(state.id)) {
            return state;
        }
        switch (action.type) {
            case FocusAction.TYPE:
            case UnfocusAction.TYPE:
            case AddGroupControlAction.TYPE:
            case RemoveGroupControlAction.TYPE:
                return childReducer$1(state, action);
            default:
                break;
        }
        state = setValueReducer$1(state, action);
        state = setErrorsReducer$1(state, action);
        state = startAsyncValidationReducer$1(state, action);
        state = setAsyncErrorReducer$1(state, action);
        state = clearAsyncErrorReducer$1(state, action);
        state = enableReducer$1(state, action);
        state = disableReducer$1(state, action);
        state = markAsDirtyReducer$1(state, action);
        state = markAsPristineReducer$1(state, action);
        state = markAsTouchedReducer$1(state, action);
        state = markAsUntouchedReducer$1(state, action);
        state = markAsSubmittedReducer$1(state, action);
        state = markAsUnsubmittedReducer$1(state, action);
        state = setUserDefinedPropertyReducer$1(state, action);
        state = resetReducer$1(state, action);
        state = addControlReducer$1(state, action);
        state = removeControlReducer$1(state, action);
        state = swapControlReducer(state, action);
        state = moveControlReducer(state, action);
        return state;
    }
    /**
     * This reducer function updates a form array state with actions.
     */
    function formArrayReducer(state, action) {
        if (!state) {
            throw new Error('The array state must be defined!');
        }
        return formArrayReducerInternal(state, action);
    }

    function formStateReducer(state, action) {
        if (!state) {
            throw new Error('The form state must be defined!');
        }
        if (!isFormState(state)) {
            throw new Error("state must be a form state, got " + state);
        }
        if (isGroupState(state)) {
            return formGroupReducer(state, action);
        }
        if (isArrayState(state)) {
            return formArrayReducer(state, action);
        }
        return formControlReducer(state, action);
    }
    /**
     * This function creates a reducer function that first applies an action to the state
     * and afterwards applies all given update functions one after another to the resulting
     * form state. However, the update functions are only applied if the form state changed
     * as result of applying the action. If you need the update functions to be applied
     * regardless of whether the state changed (e.g. because the update function closes
     * over variables that may change independently of the form state) you can simply apply
     * the update manually (e.g. `updateFunction(formStateReducer(state, action))`).
     *
     * The following (contrived) example uses this function to create a reducer that after
     * each action validates the child control `name` to be required and sets the child
     * control `email`'s value to be `''` if the name is invalid.
     *
    ```typescript
    interface FormValue {
      name: string;
      email: string;
    }

    const updateFormState = updateGroup<FormValue>(
      {
        name: validate(required),
      },
      {
        email: (email, parentGroup) =>
          parentGroup.controls.name.isInvalid
            ? setValue('', email)
            : email,
      },
    );

    const reducer = createFormStateReducerWithUpdate<FormValue>(updateFormState);
    ```
     */
    function createFormStateReducerWithUpdate(updateFnOrUpdateFnArr) {
        var updateFnArr = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            updateFnArr[_i - 1] = arguments[_i];
        }
        updateFnArr = __spreadArray(__spreadArray([], __read((Array.isArray(updateFnOrUpdateFnArr) ? updateFnOrUpdateFnArr : [updateFnOrUpdateFnArr]))), __read(updateFnArr));
        return function (state, action) {
            var newState = formStateReducer(state, action);
            return newState === state ? state : updateFnArr.reduce(function (s, f) { return f(s); }, newState);
        };
    }
    function reduceNestedFormState(state, key, action) {
        var _a;
        var value = state[key];
        if (!isFormState(value)) {
            return state;
        }
        return Object.assign(Object.assign({}, state), (_a = {}, _a[key] = formStateReducer(value, action), _a));
    }
    function reduceNestedFormStates(state, action) {
        return Object.keys(state).reduce(function (s, key) { return reduceNestedFormState(s, key, action); }, state);
    }
    /**
     * This function returns an object that can be passed to ngrx's `createReducer`
     * function (available starting with ngrx version 8). By doing this all form
     * state properties on the state will be updated whenever necessary (i.e.
     * whenever an ngrx-forms action is dispatched).
     *
     * To manually update a form state (e.g. to validate it) use
     * `wrapReducerWithFormStateUpdate`.
     */
    function onNgrxForms() {
        return {
            reducer: function (state, action) { return isFormState(state) ? formStateReducer(state, action) : reduceNestedFormStates(state, action); },
            types: ALL_NGRX_FORMS_ACTION_TYPES,
        };
    }
    /**
     * Define a reducer for a ngrx-forms action. This functions works the same as
     * ngrx's `on` except that you provide the ngrx-forms action class instead of
     * your action creator as a parameter.
     */
    function onNgrxFormsAction(actionCons, reducer) {
        return {
            reducer: function (state, action) { return reducer(reduceNestedFormStates(state, action), action); },
            types: [actionCons.TYPE],
        };
    }
    /**
     * This function wraps a reducer and returns another reducer that first calls
     * the given reducer and then calls the given update function for the form state
     * that is specified by the form state locator function.
     *
     * The update function is passed the form state and the updated containing state
     * as parameters.
     */
    function wrapReducerWithFormStateUpdate(reducer, formStateLocator, updateFn) {
        return function (state, action) {
            var _a;
            var updatedState = reducer(state, action);
            var formState = formStateLocator(updatedState);
            // if the state itself is the form state, update it directly
            if (formState === updatedState) {
                return updateFn(formState, updatedState);
            }
            var formStateKey = Object.keys(updatedState).find(function (key) { return updatedState[key] === formState; });
            var updatedFormState = updateFn(formState, updatedState);
            if (updatedFormState === formState) {
                return updatedState;
            }
            return Object.assign(Object.assign({}, updatedState), (_a = {}, _a[formStateKey] = updatedFormState, _a));
        };
    }

    function dispatchActionPerChild(controls, actionCreator) {
        var hasChanged = false;
        var newControls = Object.keys(controls)
            .reduce(function (c, key) {
            var _a;
            Object.assign(c, (_a = {}, _a[key] = formStateReducer(controls[key], actionCreator(controls[key].id)), _a));
            hasChanged = hasChanged || c[key] !== controls[key];
            return c;
        }, {});
        return hasChanged ? newControls : controls;
    }
    function callChildReducers(controls, action) {
        var hasChanged = false;
        var newControls = Object.keys(controls)
            .map(function (key) { return [key, formStateReducer(controls[key], action)]; })
            .reduce(function (res, _a) {
            var _b;
            var _c = __read(_a, 2), key = _c[0], state = _c[1];
            hasChanged = hasChanged || state !== controls[key];
            return Object.assign(res, (_b = {}, _b[key] = state, _b));
        }, {});
        return hasChanged ? newControls : controls;
    }
    function childReducer(state, action) {
        var controls = callChildReducers(state.controls, action);
        if (state.controls === controls) {
            return state;
        }
        return computeGroupState(state.id, controls, state.value, state.errors, state.pendingValidations, state.userDefinedProperties, {
            wasOrShouldBeDirty: state.isDirty,
            wasOrShouldBeEnabled: state.isEnabled,
            wasOrShouldBeTouched: state.isTouched,
            wasOrShouldBeSubmitted: state.isSubmitted,
        });
    }

    function addControlReducer(state, action) {
        var _a;
        if (action.type !== AddGroupControlAction.TYPE) {
            return state;
        }
        if (action.controlId !== state.id) {
            return childReducer(state, action);
        }
        if (state.controls.hasOwnProperty(action.name)) {
            throw new Error("Group '" + state.id + "' already has child control '" + action.name + "'!"); // `;
        }
        var controls = Object.assign({}, state.controls, (_a = {},
            _a[action.name] = createChildState(state.id + "." + action.name, action.value),
            _a));
        return computeGroupState(state.id, controls, state.value, state.errors, state.pendingValidations, state.userDefinedProperties, {
            wasOrShouldBeDirty: true,
            wasOrShouldBeEnabled: state.isEnabled,
            wasOrShouldBeTouched: state.isTouched,
            wasOrShouldBeSubmitted: state.isSubmitted,
        });
    }

    function clearAsyncErrorReducer(state, action) {
        if (action.type !== ClearAsyncErrorAction.TYPE) {
            return state;
        }
        if (action.controlId !== state.id) {
            return childReducer(state, action);
        }
        var name = "$" + action.name;
        var errors = state.errors;
        if (errors.hasOwnProperty(name)) {
            errors = Object.assign({}, state.errors);
            delete errors[name];
        }
        var pendingValidations = state.pendingValidations.filter(function (v) { return v !== action.name; });
        if (errors === state.errors && pendingValidations.length === state.pendingValidations.length) {
            return state;
        }
        return computeGroupState(state.id, state.controls, state.value, errors, pendingValidations, state.userDefinedProperties, {
            wasOrShouldBeDirty: state.isDirty,
            wasOrShouldBeEnabled: state.isEnabled,
            wasOrShouldBeTouched: state.isTouched,
            wasOrShouldBeSubmitted: state.isSubmitted,
        });
    }

    function disableReducer(state, action) {
        if (action.type !== DisableAction.TYPE) {
            return state;
        }
        if (action.controlId !== state.id) {
            return childReducer(state, action);
        }
        if (state.isDisabled) {
            return state;
        }
        return computeGroupState(state.id, dispatchActionPerChild(state.controls, function (controlId) { return new DisableAction(controlId); }), state.value, {}, [], state.userDefinedProperties, {
            wasOrShouldBeDirty: state.isDirty,
            wasOrShouldBeEnabled: false,
            wasOrShouldBeTouched: state.isTouched,
            wasOrShouldBeSubmitted: state.isSubmitted,
        });
    }

    function enableReducer(state, action) {
        if (action.type !== EnableAction.TYPE) {
            return state;
        }
        if (action.controlId !== state.id) {
            return childReducer(state, action);
        }
        var controls = dispatchActionPerChild(state.controls, function (controlId) { return new EnableAction(controlId); });
        if (controls === state.controls) {
            return state;
        }
        return computeGroupState(state.id, controls, state.value, state.errors, state.pendingValidations, state.userDefinedProperties, {
            wasOrShouldBeDirty: state.isDirty,
            wasOrShouldBeEnabled: true,
            wasOrShouldBeTouched: state.isTouched,
            wasOrShouldBeSubmitted: state.isSubmitted,
        });
    }

    function markAsDirtyReducer(state, action) {
        if (action.type !== MarkAsDirtyAction.TYPE) {
            return state;
        }
        if (action.controlId !== state.id) {
            return childReducer(state, action);
        }
        var controls = dispatchActionPerChild(state.controls, function (controlId) { return new MarkAsDirtyAction(controlId); });
        if (controls === state.controls) {
            return state;
        }
        return computeGroupState(state.id, controls, state.value, state.errors, state.pendingValidations, state.userDefinedProperties, {
            wasOrShouldBeDirty: true,
            wasOrShouldBeEnabled: state.isEnabled,
            wasOrShouldBeTouched: state.isTouched,
            wasOrShouldBeSubmitted: state.isSubmitted,
        });
    }

    function markAsPristineReducer(state, action) {
        if (action.type !== MarkAsPristineAction.TYPE) {
            return state;
        }
        if (action.controlId !== state.id) {
            return childReducer(state, action);
        }
        if (state.isPristine) {
            return state;
        }
        return computeGroupState(state.id, dispatchActionPerChild(state.controls, function (controlId) { return new MarkAsPristineAction(controlId); }), state.value, state.errors, state.pendingValidations, state.userDefinedProperties, {
            wasOrShouldBeDirty: false,
            wasOrShouldBeEnabled: state.isEnabled,
            wasOrShouldBeTouched: state.isTouched,
            wasOrShouldBeSubmitted: state.isSubmitted,
        });
    }

    function markAsSubmittedReducer(state, action) {
        if (action.type !== MarkAsSubmittedAction.TYPE) {
            return state;
        }
        if (action.controlId !== state.id) {
            return childReducer(state, action);
        }
        var controls = dispatchActionPerChild(state.controls, function (controlId) { return new MarkAsSubmittedAction(controlId); });
        if (controls === state.controls) {
            return state;
        }
        return computeGroupState(state.id, controls, state.value, state.errors, state.pendingValidations, state.userDefinedProperties, {
            wasOrShouldBeDirty: state.isDirty,
            wasOrShouldBeEnabled: state.isEnabled,
            wasOrShouldBeTouched: state.isTouched,
            wasOrShouldBeSubmitted: true,
        });
    }

    function markAsTouchedReducer(state, action) {
        if (action.type !== MarkAsTouchedAction.TYPE) {
            return state;
        }
        if (action.controlId !== state.id) {
            return childReducer(state, action);
        }
        var controls = dispatchActionPerChild(state.controls, function (controlId) { return new MarkAsTouchedAction(controlId); });
        if (controls === state.controls) {
            return state;
        }
        return computeGroupState(state.id, controls, state.value, state.errors, state.pendingValidations, state.userDefinedProperties, {
            wasOrShouldBeDirty: state.isDirty,
            wasOrShouldBeEnabled: state.isEnabled,
            wasOrShouldBeTouched: true,
            wasOrShouldBeSubmitted: state.isSubmitted,
        });
    }

    function markAsUnsubmittedReducer(state, action) {
        if (action.type !== MarkAsUnsubmittedAction.TYPE) {
            return state;
        }
        if (action.controlId !== state.id) {
            return childReducer(state, action);
        }
        if (state.isUnsubmitted) {
            return state;
        }
        return computeGroupState(state.id, dispatchActionPerChild(state.controls, function (controlId) { return new MarkAsUnsubmittedAction(controlId); }), state.value, state.errors, state.pendingValidations, state.userDefinedProperties, {
            wasOrShouldBeDirty: state.isDirty,
            wasOrShouldBeEnabled: state.isEnabled,
            wasOrShouldBeTouched: state.isTouched,
            wasOrShouldBeSubmitted: false,
        });
    }

    function markAsUntouchedReducer(state, action) {
        if (action.type !== MarkAsUntouchedAction.TYPE) {
            return state;
        }
        if (action.controlId !== state.id) {
            return childReducer(state, action);
        }
        if (state.isUntouched) {
            return state;
        }
        return computeGroupState(state.id, dispatchActionPerChild(state.controls, function (controlId) { return new MarkAsUntouchedAction(controlId); }), state.value, state.errors, state.pendingValidations, state.userDefinedProperties, {
            wasOrShouldBeDirty: state.isDirty,
            wasOrShouldBeEnabled: state.isEnabled,
            wasOrShouldBeTouched: false,
            wasOrShouldBeSubmitted: state.isSubmitted,
        });
    }

    function removeControlReducer(state, action) {
        if (action.type !== RemoveGroupControlAction.TYPE) {
            return state;
        }
        if (action.controlId !== state.id) {
            return childReducer(state, action);
        }
        if (!state.controls.hasOwnProperty(action.name)) {
            throw new Error("Group '" + state.id + "' does not have child control '" + action.name + "'!"); // `;
        }
        var controls = Object.assign({}, state.controls);
        delete controls[action.name];
        return computeGroupState(state.id, controls, state.value, state.errors, state.pendingValidations, state.userDefinedProperties, {
            wasOrShouldBeDirty: true,
            wasOrShouldBeEnabled: state.isEnabled,
            wasOrShouldBeTouched: state.isTouched,
            wasOrShouldBeSubmitted: state.isSubmitted,
        });
    }

    function resetReducer(state, action) {
        if (action.type !== ResetAction.TYPE) {
            return state;
        }
        if (action.controlId !== state.id) {
            return childReducer(state, action);
        }
        if (state.isPristine && state.isUntouched && state.isUnsubmitted) {
            return state;
        }
        return computeGroupState(state.id, dispatchActionPerChild(state.controls, function (controlId) { return new ResetAction(controlId); }), state.value, state.errors, state.pendingValidations, state.userDefinedProperties, {
            wasOrShouldBeDirty: false,
            wasOrShouldBeEnabled: state.isEnabled,
            wasOrShouldBeTouched: false,
            wasOrShouldBeSubmitted: false,
        });
    }

    function setAsyncErrorReducer(state, action) {
        var _a;
        if (action.type !== SetAsyncErrorAction.TYPE) {
            return state;
        }
        if (action.controlId !== state.id) {
            return childReducer(state, action);
        }
        if (state.isDisabled) {
            return state;
        }
        var name = "$" + action.name;
        var value = action.value;
        if (deepEquals(state.errors[name], action.value)) {
            value = state.errors[name];
        }
        var errors = Object.assign(Object.assign({}, state.errors), (_a = {}, _a[name] = value, _a));
        var pendingValidations = state.pendingValidations.filter(function (v) { return v !== action.name; });
        return computeGroupState(state.id, state.controls, state.value, errors, pendingValidations, state.userDefinedProperties, {
            wasOrShouldBeDirty: state.isDirty,
            wasOrShouldBeEnabled: state.isEnabled,
            wasOrShouldBeTouched: state.isTouched,
            wasOrShouldBeSubmitted: state.isSubmitted,
        });
    }

    function setErrorsReducer(state, action) {
        if (action.type !== SetErrorsAction.TYPE) {
            return state;
        }
        if (action.controlId !== state.id) {
            return childReducer(state, action);
        }
        if (state.isDisabled) {
            return state;
        }
        if (state.errors === action.errors) {
            return state;
        }
        if (deepEquals(state.errors, action.errors)) {
            return state;
        }
        if (!action.errors || typeof action.errors !== 'object' || Array.isArray(action.errors)) {
            throw new Error("Control errors must be an object; got " + action.errors); // `;
        }
        if (Object.keys(action.errors).some(function (key) { return key.startsWith('_'); })) {
            throw new Error("Control errors must not use underscore as a prefix; got " + JSON.stringify(action.errors)); // `;
        }
        if (Object.keys(action.errors).some(function (key) { return key.startsWith('$'); })) {
            throw new Error("Control errors must not use $ as a prefix; got " + JSON.stringify(action.errors)); // `;
        }
        var childAndAsyncErrors = Object.keys(state.errors)
            .filter(function (key) { return key.startsWith('_') || key.startsWith('$'); })
            .reduce(function (res, key) {
            var _a;
            return Object.assign(res, (_a = {}, _a[key] = state.errors[key], _a));
        }, {});
        var newErrors = Object.assign(childAndAsyncErrors, action.errors);
        return computeGroupState(state.id, state.controls, state.value, newErrors, state.pendingValidations, state.userDefinedProperties, {
            wasOrShouldBeDirty: state.isDirty,
            wasOrShouldBeEnabled: state.isEnabled,
            wasOrShouldBeTouched: state.isTouched,
            wasOrShouldBeSubmitted: state.isSubmitted,
        });
    }

    function setUserDefinedPropertyReducer(state, action) {
        var _a;
        if (action.type !== SetUserDefinedPropertyAction.TYPE) {
            return state;
        }
        if (action.controlId !== state.id) {
            return childReducer(state, action);
        }
        if (state.userDefinedProperties[action.name] === action.value) {
            return state;
        }
        return Object.assign(Object.assign({}, state), { userDefinedProperties: Object.assign(Object.assign({}, state.userDefinedProperties), (_a = {}, _a[action.name] = action.value, _a)) });
    }

    function setValueReducer(state, action) {
        if (action.type !== SetValueAction.TYPE) {
            return state;
        }
        if (action.controlId !== state.id) {
            return childReducer(state, action);
        }
        if (state.value === action.value) {
            return state;
        }
        if (action.value instanceof Date) {
            throw new Error('Date values are not supported. Please used serialized strings instead.');
        }
        var value = action.value;
        var controls = Object.keys(value)
            .reduce(function (c, key) {
            var _a, _b;
            // tslint:disable-next-line:prefer-conditional-expression
            if (!state.controls[key]) {
                Object.assign(c, (_a = {}, _a[key] = createChildState(state.id + "." + key, value[key]), _a));
            }
            else {
                Object.assign(c, (_b = {}, _b[key] = formStateReducer(state.controls[key], new SetValueAction(state.controls[key].id, value[key])), _b));
            }
            return c;
        }, {});
        return computeGroupState(state.id, controls, value, state.errors, state.pendingValidations, state.userDefinedProperties, {
            wasOrShouldBeDirty: state.isDirty,
            wasOrShouldBeEnabled: state.isEnabled,
            wasOrShouldBeTouched: state.isTouched,
            wasOrShouldBeSubmitted: state.isSubmitted,
        });
    }

    function startAsyncValidationReducer(state, action) {
        if (action.type !== StartAsyncValidationAction.TYPE) {
            return state;
        }
        if (action.controlId !== state.id) {
            return childReducer(state, action);
        }
        if (state.pendingValidations.indexOf(action.name) >= 0) {
            return state;
        }
        var pendingValidations = __spreadArray(__spreadArray([], __read(state.pendingValidations)), [action.name]);
        return computeGroupState(state.id, state.controls, state.value, state.errors, pendingValidations, state.userDefinedProperties, {
            wasOrShouldBeDirty: state.isDirty,
            wasOrShouldBeEnabled: state.isEnabled,
            wasOrShouldBeTouched: state.isTouched,
            wasOrShouldBeSubmitted: state.isSubmitted,
        });
    }

    function formGroupReducerInternal(state, action) {
        if (!isGroupState(state)) {
            throw new Error('The state must be a group state');
        }
        if (!isNgrxFormsAction(action)) {
            return state;
        }
        if (!action.controlId.startsWith(state.id)) {
            return state;
        }
        switch (action.type) {
            case FocusAction.TYPE:
            case UnfocusAction.TYPE:
            case AddArrayControlAction.TYPE:
            case RemoveArrayControlAction.TYPE:
            case MoveArrayControlAction.TYPE:
            case SwapArrayControlAction.TYPE:
                return childReducer(state, action);
            default:
                break;
        }
        state = setValueReducer(state, action);
        state = setErrorsReducer(state, action);
        state = startAsyncValidationReducer(state, action);
        state = setAsyncErrorReducer(state, action);
        state = clearAsyncErrorReducer(state, action);
        state = enableReducer(state, action);
        state = disableReducer(state, action);
        state = markAsDirtyReducer(state, action);
        state = markAsPristineReducer(state, action);
        state = markAsTouchedReducer(state, action);
        state = markAsUntouchedReducer(state, action);
        state = markAsSubmittedReducer(state, action);
        state = markAsUnsubmittedReducer(state, action);
        state = addControlReducer(state, action);
        state = removeControlReducer(state, action);
        state = setUserDefinedPropertyReducer(state, action);
        state = resetReducer(state, action);
        return state;
    }
    /**
     * This reducer function updates a form group state with actions.
     */
    function formGroupReducer(state, action) {
        if (!state) {
            throw new Error('The group state must be defined!');
        }
        return formGroupReducerInternal(state, action);
    }

    function abstractControlReducer(state, action) {
        if (isArrayState(state)) {
            return formArrayReducer(state, action);
        }
        if (isGroupState(state)) {
            return formGroupReducer(state, action);
        }
        return formControlReducer(state, action);
    }
    function compose() {
        var fns = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            fns[_i] = arguments[_i];
        }
        return function (t) { return fns.reduce(function (res, f) { return f(res); }, t); };
    }
    function ensureState(state) {
        if (!state) {
            throw new Error('state must not be undefined!');
        }
        return state;
    }

    function updateArrayControlsState(filterFn, updateFn) {
        return function (state) {
            var hasChanged = false;
            var newControls = state.controls.map(function (control, idx) {
                if (!filterFn(control, idx)) {
                    return control;
                }
                var newControl = updateFn(control, state);
                hasChanged = hasChanged || newControl !== control;
                return newControl;
            });
            return hasChanged ? newControls : state.controls;
        };
    }
    function updateArraySingle(filterFn, updateFn) {
        return function (state) {
            var newControls = updateArrayControlsState(filterFn, updateFn)(state);
            return newControls !== state.controls
                ? computeArrayState(state.id, newControls, state.value, state.errors, state.pendingValidations, state.userDefinedProperties, {
                    wasOrShouldBeDirty: state.isDirty,
                    wasOrShouldBeEnabled: state.isEnabled,
                    wasOrShouldBeTouched: state.isTouched,
                    wasOrShouldBeSubmitted: state.isSubmitted,
                })
                : state;
        };
    }
    function updateArrayWithFilter(stateOrFilterFunction, filterFunctionOrFunctionOrFunctionArray, updateFnOrUpdateFnArr) {
        var rest = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            rest[_i - 3] = arguments[_i];
        }
        if (isArrayState(stateOrFilterFunction)) {
            var filterFn_1 = filterFunctionOrFunctionOrFunctionArray;
            var updateFnArr_1 = Array.isArray(updateFnOrUpdateFnArr) ? updateFnOrUpdateFnArr : [updateFnOrUpdateFnArr];
            return updateFnArr_1.concat.apply(updateFnArr_1, __spreadArray([], __read(rest))).reduce(function (s, updateFn) { return updateArraySingle(filterFn_1, updateFn)(s); }, stateOrFilterFunction);
        }
        var updateFnArr = Array.isArray(filterFunctionOrFunctionOrFunctionArray)
            ? filterFunctionOrFunctionOrFunctionArray
            : [filterFunctionOrFunctionOrFunctionArray];
        updateFnArr = updateFnOrUpdateFnArr === undefined ? updateFnArr : updateFnArr.concat(updateFnOrUpdateFnArr);
        return function (s) { return updateArrayWithFilter(ensureState(s), stateOrFilterFunction, updateFnArr.concat(rest)); };
    }
    function updateArray(stateOrFunctionOrFunctionArray, updateFnOrUpdateFnArr) {
        var rest = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            rest[_i - 2] = arguments[_i];
        }
        if (isArrayState(stateOrFunctionOrFunctionArray)) {
            var updateFnArr_2 = Array.isArray(updateFnOrUpdateFnArr) ? updateFnOrUpdateFnArr : [updateFnOrUpdateFnArr];
            return updateFnArr_2.concat.apply(updateFnArr_2, __spreadArray([], __read(rest))).reduce(function (s, updateFn) { return updateArraySingle(function () { return true; }, updateFn)(s); }, stateOrFunctionOrFunctionArray);
        }
        var updateFnArr = Array.isArray(stateOrFunctionOrFunctionArray) ? stateOrFunctionOrFunctionArray : [stateOrFunctionOrFunctionArray];
        updateFnArr = updateFnOrUpdateFnArr === undefined ? updateFnArr : updateFnArr.concat(updateFnOrUpdateFnArr);
        return function (s) { return updateArray(ensureState(s), updateFnArr.concat(rest)); };
    }

    function updateGroupControlsState(updateFns) {
        return function (state) {
            var hasChanged = false;
            var newControls = Object.keys(state.controls).reduce(function (res, key) {
                var _a, _b;
                var control = state.controls[key];
                Object.assign(res, (_a = {}, _a[key] = control, _a));
                if (updateFns.hasOwnProperty(key)) {
                    var newControl = updateFns[key](control, state);
                    hasChanged = hasChanged || newControl !== control;
                    Object.assign(res, (_b = {}, _b[key] = newControl, _b));
                }
                return res;
            }, {});
            return hasChanged ? newControls : state.controls;
        };
    }
    function updateGroupSingle(updateFns) {
        return function (state) {
            var newControls = updateGroupControlsState(updateFns)(state);
            return newControls !== state.controls
                ? computeGroupState(state.id, newControls, state.value, state.errors, state.pendingValidations, state.userDefinedProperties, {
                    wasOrShouldBeDirty: state.isDirty,
                    wasOrShouldBeEnabled: state.isEnabled,
                    wasOrShouldBeTouched: state.isTouched,
                    wasOrShouldBeSubmitted: state.isSubmitted,
                })
                : state;
        };
    }
    function updateGroup(stateOrUpdateFnOrUpdateFnArray, updateFnOrUpdateFnArr) {
        var rest = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            rest[_i - 2] = arguments[_i];
        }
        if (isGroupState(stateOrUpdateFnOrUpdateFnArray)) {
            var updateFnArr_1 = Array.isArray(updateFnOrUpdateFnArr) ? updateFnOrUpdateFnArr : [updateFnOrUpdateFnArr];
            return updateFnArr_1.concat.apply(updateFnArr_1, __spreadArray([], __read(rest))).reduce(function (s, updateFn) { return updateGroupSingle(updateFn)(s); }, stateOrUpdateFnOrUpdateFnArray);
        }
        var updateFnArr = Array.isArray(stateOrUpdateFnOrUpdateFnArray) ? stateOrUpdateFnOrUpdateFnArray : [stateOrUpdateFnOrUpdateFnArray];
        updateFnArr = updateFnOrUpdateFnArr === undefined ? updateFnArr : updateFnArr.concat(updateFnOrUpdateFnArr);
        return function (s) { return updateGroup(ensureState(s), updateFnArr.concat(rest)); };
    }

    function updateRecursiveSingle(parent, updateFn) {
        return function (state) {
            if (isGroupState(state)) {
                var updateFunctions = Object.keys(state.controls).reduce(function (agg, key) {
                    var _a;
                    return Object.assign(agg, (_a = {},
                        _a[key] = function (s, p) { return updateRecursiveSingle(p, updateFn)(s); },
                        _a));
                }, {});
                state = updateGroup(updateFunctions)(state);
                return updateFn(state, parent);
            }
            if (isArrayState(state)) {
                state = updateArray(function (s, p) { return updateRecursiveSingle(p, updateFn)(s); })(state);
                return updateFn(state, parent);
            }
            return updateFn(state, parent);
        };
    }
    function updateRecursive(stateOrFunctionOrFunctionArray, updateFnOrUpdateFnArr) {
        var rest = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            rest[_i - 2] = arguments[_i];
        }
        if (isFormState(stateOrFunctionOrFunctionArray)) {
            var updateFnArr_1 = Array.isArray(updateFnOrUpdateFnArr) ? updateFnOrUpdateFnArr : [updateFnOrUpdateFnArr];
            return updateFnArr_1.concat.apply(updateFnArr_1, __spreadArray([], __read(rest))).reduce(function (s, updateFn) { return updateRecursiveSingle(stateOrFunctionOrFunctionArray, updateFn)(s); }, stateOrFunctionOrFunctionArray);
        }
        var updateFnArr = Array.isArray(stateOrFunctionOrFunctionArray) ? stateOrFunctionOrFunctionArray : [stateOrFunctionOrFunctionArray];
        updateFnArr = updateFnOrUpdateFnArr === undefined ? updateFnArr : updateFnArr.concat(updateFnOrUpdateFnArr);
        return function (s) { return updateRecursive(ensureState(s), updateFnArr.concat(rest)); };
    }

    function setValue(valueOrState, value) {
        if (isFormState(valueOrState)) {
            return abstractControlReducer(valueOrState, new SetValueAction(valueOrState.id, value));
        }
        return function (s) { return setValue(ensureState(s), valueOrState); };
    }

    function setErrors(errorsOrErrorsArrayOrState, errorsOrErrorsArray) {
        var rest = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            rest[_i - 2] = arguments[_i];
        }
        if (isFormState(errorsOrErrorsArrayOrState)) {
            var state = errorsOrErrorsArrayOrState;
            var errorsArray_1 = Array.isArray(errorsOrErrorsArray) ? errorsOrErrorsArray : [errorsOrErrorsArray];
            var errors = errorsArray_1.concat.apply(errorsArray_1, __spreadArray([], __read(rest))).reduce(function (agg, err) { return Object.assign(agg, err); }, {});
            return formStateReducer(state, new SetErrorsAction(state.id, errors));
        }
        var errorsArray = Array.isArray(errorsOrErrorsArrayOrState) ? errorsOrErrorsArrayOrState : [errorsOrErrorsArrayOrState];
        errorsArray = errorsOrErrorsArray === undefined ? errorsArray : errorsArray.concat(errorsOrErrorsArray);
        return function (s) { return setErrors(ensureState(s), errorsArray.concat(rest)); };
    }

    function validate(stateOrFunctionOrFunctionArray, functionOrFunctionArr) {
        var rest = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            rest[_i - 2] = arguments[_i];
        }
        if (isFormState(stateOrFunctionOrFunctionArray)) {
            var state_1 = stateOrFunctionOrFunctionArray;
            var functionArr = Array.isArray(functionOrFunctionArr) ? functionOrFunctionArr : [functionOrFunctionArr];
            var errors = functionArr.concat.apply(functionArr, __spreadArray([], __read(rest))).reduce(function (agg, validationFn) { return Object.assign(agg, validationFn(state_1.value)); }, {});
            return formStateReducer(stateOrFunctionOrFunctionArray, new SetErrorsAction(state_1.id, errors));
        }
        var functionOrFunctionArray = stateOrFunctionOrFunctionArray;
        var updateFnArr = Array.isArray(functionOrFunctionArray) ? functionOrFunctionArray : [functionOrFunctionArray];
        updateFnArr = functionOrFunctionArr === undefined ? updateFnArr : updateFnArr.concat(functionOrFunctionArr);
        return function (s) { return validate(ensureState(s), updateFnArr.concat(rest)); };
    }

    function enable(state) {
        return abstractControlReducer(state, new EnableAction(state.id));
    }

    function disable(state) {
        return abstractControlReducer(state, new DisableAction(state.id));
    }

    function markAsDirty(state) {
        return abstractControlReducer(state, new MarkAsDirtyAction(state.id));
    }

    function markAsPristine(state) {
        return abstractControlReducer(state, new MarkAsPristineAction(state.id));
    }

    function markAsTouched(state) {
        return abstractControlReducer(state, new MarkAsTouchedAction(state.id));
    }

    function markAsUntouched(state) {
        return abstractControlReducer(state, new MarkAsUntouchedAction(state.id));
    }

    function markAsSubmitted(state) {
        return abstractControlReducer(state, new MarkAsSubmittedAction(state.id));
    }

    function markAsUnsubmitted(state) {
        return abstractControlReducer(state, new MarkAsUnsubmittedAction(state.id));
    }

    /**
     * This update function takes a form control state and marks it as focused (which
     * will also `.focus()` the form element).
     */
    function focus(state) {
        return formControlReducer(state, new FocusAction(state.id));
    }

    /**
     * This update function takes a form control state and marks it as not focused (which
     * will also `.blur()` the form element).
     */
    function unfocus(state) {
        return formControlReducer(state, new UnfocusAction(state.id));
    }

    function addArrayControl(valueOrState, indexOrValue, index) {
        if (isArrayState(valueOrState)) {
            return formArrayReducer(valueOrState, new AddArrayControlAction(valueOrState.id, indexOrValue, index));
        }
        return function (s) { return addArrayControl(ensureState(s), valueOrState, indexOrValue); };
    }

    function addGroupControl(nameOrState, valueOrName, value) {
        if (isGroupState(nameOrState)) {
            return formGroupReducer(nameOrState, new AddGroupControlAction(nameOrState.id, valueOrName, value));
        }
        return function (s) { return addGroupControl(ensureState(s), nameOrState, valueOrName); };
    }

    function moveArrayControl(indexOrState, fromIndex, toIndex) {
        if (isArrayState(indexOrState)) {
            return formArrayReducer(indexOrState, new MoveArrayControlAction(indexOrState.id, fromIndex, toIndex));
        }
        return function (s) { return moveArrayControl(ensureState(s), indexOrState, fromIndex); };
    }

    function swapArrayControl(indexOrState, fromIndex, toIndex) {
        if (isArrayState(indexOrState)) {
            return formArrayReducer(indexOrState, new SwapArrayControlAction(indexOrState.id, fromIndex, toIndex));
        }
        return function (s) { return swapArrayControl(ensureState(s), indexOrState, fromIndex); };
    }

    function removeArrayControl(indexOrState, index) {
        if (isArrayState(indexOrState)) {
            return formArrayReducer(indexOrState, new RemoveArrayControlAction(indexOrState.id, index));
        }
        return function (s) { return removeArrayControl(ensureState(s), indexOrState); };
    }

    function removeGroupControl(nameOrState, name) {
        if (isGroupState(nameOrState)) {
            return formGroupReducer(nameOrState, new RemoveGroupControlAction(nameOrState.id, name));
        }
        return function (s) { return removeGroupControl(ensureState(s), nameOrState); };
    }

    function setUserDefinedProperty(nameOrState, valueOrName, value) {
        if (isFormState(nameOrState)) {
            var state = nameOrState;
            return formStateReducer(nameOrState, new SetUserDefinedPropertyAction(state.id, valueOrName, value));
        }
        return function (s) { return setUserDefinedProperty(ensureState(s), nameOrState, valueOrName); };
    }

    function reset(state) {
        return abstractControlReducer(state, new ResetAction(state.id));
    }

    function startAsyncValidation(nameOrState, name) {
        if (isFormState(nameOrState)) {
            return abstractControlReducer(nameOrState, new StartAsyncValidationAction(nameOrState.id, name));
        }
        return function (s) { return startAsyncValidation(ensureState(s), nameOrState); };
    }

    function setAsyncError(nameOrState, nameOrValue, value) {
        if (isFormState(nameOrState)) {
            return abstractControlReducer(nameOrState, new SetAsyncErrorAction(nameOrState.id, nameOrValue, value));
        }
        return function (s) { return setAsyncError(ensureState(s), nameOrState, nameOrValue); };
    }

    function clearAsyncError(nameOrState, name) {
        if (isFormState(nameOrState)) {
            return abstractControlReducer(nameOrState, new ClearAsyncErrorAction(nameOrState.id, name));
        }
        return function (s) { return clearAsyncError(ensureState(s), nameOrState); };
    }

    /**
     * Used to provide a {@link FormViewAdapter} for form elements.
     */
    var NGRX_FORM_VIEW_ADAPTER = new i0.InjectionToken('NgrxFormViewAdapter');

    // tslint:disable:directive-class-suffix
    var NgrxCheckboxViewAdapter = /** @class */ (function () {
        function NgrxCheckboxViewAdapter(renderer, elementRef) {
            this.renderer = renderer;
            this.elementRef = elementRef;
            this.nativeIdWasSet = false;
            this.onChange = function () { return void 0; };
            this.onTouched = function () { return void 0; };
        }
        Object.defineProperty(NgrxCheckboxViewAdapter.prototype, "ngrxFormControlState", {
            set: function (value) {
                if (!value) {
                    throw new Error('The control state must not be undefined!');
                }
                this.state = value;
                var nativeId = this.elementRef.nativeElement.id;
                var shouldSetNativeId = value.id !== nativeId && this.nativeIdWasSet;
                if (shouldSetNativeId) {
                    this.renderer.setProperty(this.elementRef.nativeElement, 'id', value.id);
                }
            },
            enumerable: false,
            configurable: true
        });
        NgrxCheckboxViewAdapter.prototype.ngAfterViewInit = function () {
            var nativeId = this.elementRef.nativeElement.id;
            var shouldSetNativeId = this.state.id !== nativeId && !nativeId;
            if (shouldSetNativeId) {
                this.renderer.setProperty(this.elementRef.nativeElement, 'id', this.state.id);
                this.nativeIdWasSet = true;
            }
        };
        NgrxCheckboxViewAdapter.prototype.setViewValue = function (value) {
            this.renderer.setProperty(this.elementRef.nativeElement, 'checked', value);
        };
        NgrxCheckboxViewAdapter.prototype.setOnChangeCallback = function (fn) {
            this.onChange = fn;
        };
        NgrxCheckboxViewAdapter.prototype.setOnTouchedCallback = function (fn) {
            this.onTouched = fn;
        };
        NgrxCheckboxViewAdapter.prototype.setIsDisabled = function (isDisabled) {
            this.renderer.setProperty(this.elementRef.nativeElement, 'disabled', isDisabled);
        };
        NgrxCheckboxViewAdapter.prototype.handleInput = function (_a) {
            var target = _a.target;
            this.onChange(target.checked);
        };
        return NgrxCheckboxViewAdapter;
    }());
    NgrxCheckboxViewAdapter.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0__namespace, type: NgrxCheckboxViewAdapter, deps: [{ token: i0__namespace.Renderer2 }, { token: i0__namespace.ElementRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    NgrxCheckboxViewAdapter.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.13", type: NgrxCheckboxViewAdapter, selector: "input[type=checkbox][ngrxFormControlState]", inputs: { ngrxFormControlState: "ngrxFormControlState" }, host: { listeners: { "blur": "onTouched()", "change": "handleInput($event)" } }, providers: [{
                provide: NGRX_FORM_VIEW_ADAPTER,
                useExisting: i0.forwardRef(function () { return NgrxCheckboxViewAdapter; }),
                multi: true,
            }], ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0__namespace, type: NgrxCheckboxViewAdapter, decorators: [{
                type: i0.Directive,
                args: [{
                        // tslint:disable-next-line:directive-selector
                        selector: 'input[type=checkbox][ngrxFormControlState]',
                        providers: [{
                                provide: NGRX_FORM_VIEW_ADAPTER,
                                useExisting: i0.forwardRef(function () { return NgrxCheckboxViewAdapter; }),
                                multi: true,
                            }],
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.Renderer2 }, { type: i0__namespace.ElementRef }]; }, propDecorators: { onTouched: [{
                    type: i0.HostListener,
                    args: ['blur']
                }], ngrxFormControlState: [{
                    type: i0.Input
                }], handleInput: [{
                    type: i0.HostListener,
                    args: ['change', ['$event']]
                }] } });

    /**
     * We must check whether the agent is Android because composition events
     * behave differently between iOS and Android.
     */
    function isAndroid(navigator) {
        return /android (\d+)/.test(navigator.userAgent.toLowerCase());
    }
    // tslint:disable:directive-class-suffix
    // tslint:disable:directive-selector
    // TODO: since this directive has a side-effect (setting the element's id attribute)
    // it should not blacklist other types of inputs but instead it should somehow figure
    // out whether it is the "active" view adapter and only perform its side effects if it
    // is active
    var NgrxDefaultViewAdapter = /** @class */ (function () {
        function NgrxDefaultViewAdapter(renderer, elementRef, platformId, 
        // we use a special injection string that should never exist at runtime to allow mocking this dependency for testing
        navigator) {
            if (platformId === void 0) { platformId = null; }
            if (navigator === void 0) { navigator = null; }
            this.renderer = renderer;
            this.elementRef = elementRef;
            this.platformId = platformId;
            this.nativeIdWasSet = false;
            this.onChange = function () { return void 0; };
            this.onTouched = function () { return void 0; };
            /** Whether the user is creating a composition string (IME events). */
            this.isComposing = false;
            this.isCompositionSupported = common.isPlatformBrowser(this.platformId || '') && !isAndroid(navigator || window.navigator);
        }
        Object.defineProperty(NgrxDefaultViewAdapter.prototype, "ngrxFormControlState", {
            set: function (value) {
                if (!value) {
                    throw new Error('The control state must not be undefined!');
                }
                this.state = value;
                var nativeId = this.elementRef.nativeElement.id;
                var shouldSetNativeId = value.id !== nativeId && this.nativeIdWasSet;
                if (shouldSetNativeId) {
                    this.renderer.setProperty(this.elementRef.nativeElement, 'id', value.id);
                }
            },
            enumerable: false,
            configurable: true
        });
        NgrxDefaultViewAdapter.prototype.ngAfterViewInit = function () {
            var nativeId = this.elementRef.nativeElement.id;
            var shouldSetNativeId = this.state.id !== nativeId && !nativeId;
            if (shouldSetNativeId) {
                this.renderer.setProperty(this.elementRef.nativeElement, 'id', this.state.id);
                this.nativeIdWasSet = true;
            }
        };
        NgrxDefaultViewAdapter.prototype.setViewValue = function (value) {
            var normalizedValue = value == null ? '' : value;
            this.renderer.setProperty(this.elementRef.nativeElement, 'value', normalizedValue);
        };
        NgrxDefaultViewAdapter.prototype.setOnChangeCallback = function (fn) {
            this.onChange = fn;
        };
        NgrxDefaultViewAdapter.prototype.setOnTouchedCallback = function (fn) {
            this.onTouched = fn;
        };
        NgrxDefaultViewAdapter.prototype.setIsDisabled = function (isDisabled) {
            this.renderer.setProperty(this.elementRef.nativeElement, 'disabled', isDisabled);
        };
        NgrxDefaultViewAdapter.prototype.handleInput = function (_a) {
            var target = _a.target;
            if (this.isCompositionSupported && this.isComposing) {
                return;
            }
            this.onChange(target.value);
        };
        NgrxDefaultViewAdapter.prototype.compositionStart = function () {
            this.isComposing = true;
        };
        NgrxDefaultViewAdapter.prototype.compositionEnd = function (_a) {
            var target = _a.target;
            this.isComposing = false;
            if (this.isCompositionSupported) {
                this.onChange(target.value);
            }
        };
        return NgrxDefaultViewAdapter;
    }());
    NgrxDefaultViewAdapter.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0__namespace, type: NgrxDefaultViewAdapter, deps: [{ token: i0__namespace.Renderer2 }, { token: i0__namespace.ElementRef }, { token: i0.PLATFORM_ID, optional: true }, { token: 'ngrx-forms/never', optional: true }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    NgrxDefaultViewAdapter.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.13", type: NgrxDefaultViewAdapter, selector: "input:not([type=checkbox]):not([type=number]):not([type=radio]):not([type=range])[ngrxFormControlState],textarea[ngrxFormControlState]", inputs: { ngrxFormControlState: "ngrxFormControlState" }, host: { listeners: { "blur": "onTouched()", "input": "handleInput($event)", "compositionstart": "compositionStart()", "compositionend": "compositionEnd($event)" } }, providers: [{
                provide: NGRX_FORM_VIEW_ADAPTER,
                useExisting: i0.forwardRef(function () { return NgrxDefaultViewAdapter; }),
                multi: true,
            }], ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0__namespace, type: NgrxDefaultViewAdapter, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: 'input:not([type=checkbox]):not([type=number]):not([type=radio]):not([type=range])[ngrxFormControlState],textarea[ngrxFormControlState]',
                        providers: [{
                                provide: NGRX_FORM_VIEW_ADAPTER,
                                useExisting: i0.forwardRef(function () { return NgrxDefaultViewAdapter; }),
                                multi: true,
                            }],
                    }]
            }], ctorParameters: function () {
            return [{ type: i0__namespace.Renderer2 }, { type: i0__namespace.ElementRef }, { type: undefined, decorators: [{
                            type: i0.Optional
                        }, {
                            type: i0.Inject,
                            args: [i0.PLATFORM_ID]
                        }] }, { type: undefined, decorators: [{
                            type: i0.Optional
                        }, {
                            type: i0.Inject,
                            args: ['ngrx-forms/never']
                        }] }];
        }, propDecorators: { onTouched: [{
                    type: i0.HostListener,
                    args: ['blur']
                }], ngrxFormControlState: [{
                    type: i0.Input
                }], handleInput: [{
                    type: i0.HostListener,
                    args: ['input', ['$event']]
                }], compositionStart: [{
                    type: i0.HostListener,
                    args: ['compositionstart']
                }], compositionEnd: [{
                    type: i0.HostListener,
                    args: ['compositionend', ['$event']]
                }] } });

    // tslint:disable:directive-class-suffix
    var NgrxNumberViewAdapter = /** @class */ (function () {
        function NgrxNumberViewAdapter(renderer, elementRef) {
            this.renderer = renderer;
            this.elementRef = elementRef;
            this.nativeIdWasSet = false;
            this.onChange = function () { return void 0; };
            this.onTouched = function () { return void 0; };
        }
        Object.defineProperty(NgrxNumberViewAdapter.prototype, "ngrxFormControlState", {
            set: function (value) {
                if (!value) {
                    throw new Error('The control state must not be undefined!');
                }
                this.state = value;
                var nativeId = this.elementRef.nativeElement.id;
                var shouldSetNativeId = value.id !== nativeId && this.nativeIdWasSet;
                if (shouldSetNativeId) {
                    this.renderer.setProperty(this.elementRef.nativeElement, 'id', value.id);
                }
            },
            enumerable: false,
            configurable: true
        });
        NgrxNumberViewAdapter.prototype.ngAfterViewInit = function () {
            var nativeId = this.elementRef.nativeElement.id;
            var shouldSetNativeId = this.state.id !== nativeId && !nativeId;
            if (shouldSetNativeId) {
                this.renderer.setProperty(this.elementRef.nativeElement, 'id', this.state.id);
                this.nativeIdWasSet = true;
            }
        };
        NgrxNumberViewAdapter.prototype.setViewValue = function (value) {
            // The value needs to be normalized for IE9, otherwise it is set to 'null' when null
            var normalizedValue = value === null ? '' : value;
            this.renderer.setProperty(this.elementRef.nativeElement, 'value', normalizedValue);
        };
        NgrxNumberViewAdapter.prototype.setOnChangeCallback = function (fn) {
            this.onChange = fn;
        };
        NgrxNumberViewAdapter.prototype.setOnTouchedCallback = function (fn) {
            this.onTouched = fn;
        };
        NgrxNumberViewAdapter.prototype.setIsDisabled = function (isDisabled) {
            this.renderer.setProperty(this.elementRef.nativeElement, 'disabled', isDisabled);
        };
        NgrxNumberViewAdapter.prototype.handleInput = function (_a) {
            var target = _a.target;
            var value = target.value;
            this.onChange(value === '' ? null : parseFloat(value));
        };
        return NgrxNumberViewAdapter;
    }());
    NgrxNumberViewAdapter.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0__namespace, type: NgrxNumberViewAdapter, deps: [{ token: i0__namespace.Renderer2 }, { token: i0__namespace.ElementRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    NgrxNumberViewAdapter.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.13", type: NgrxNumberViewAdapter, selector: "input[type=number][ngrxFormControlState]", inputs: { ngrxFormControlState: "ngrxFormControlState" }, host: { listeners: { "blur": "onTouched()", "change": "handleInput($event)", "input": "handleInput($event)" } }, providers: [{
                provide: NGRX_FORM_VIEW_ADAPTER,
                useExisting: i0.forwardRef(function () { return NgrxNumberViewAdapter; }),
                multi: true,
            }], ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0__namespace, type: NgrxNumberViewAdapter, decorators: [{
                type: i0.Directive,
                args: [{
                        // tslint:disable-next-line:directive-selector
                        selector: 'input[type=number][ngrxFormControlState]',
                        providers: [{
                                provide: NGRX_FORM_VIEW_ADAPTER,
                                useExisting: i0.forwardRef(function () { return NgrxNumberViewAdapter; }),
                                multi: true,
                            }],
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.Renderer2 }, { type: i0__namespace.ElementRef }]; }, propDecorators: { onTouched: [{
                    type: i0.HostListener,
                    args: ['blur']
                }], ngrxFormControlState: [{
                    type: i0.Input
                }], handleInput: [{
                    type: i0.HostListener,
                    args: ['change', ['$event']]
                }, {
                    type: i0.HostListener,
                    args: ['input', ['$event']]
                }] } });

    // tslint:disable:directive-class-suffix
    var NgrxSelectViewAdapter = /** @class */ (function () {
        function NgrxSelectViewAdapter(renderer, elementRef) {
            this.renderer = renderer;
            this.elementRef = elementRef;
            this.optionMap = {};
            this.idCounter = 0;
            this.selectedId = null;
            this.value = undefined;
            this.nativeIdWasSet = false;
            this.onChangeFn = function () { return void 0; };
            this.onTouched = function () { return void 0; };
        }
        Object.defineProperty(NgrxSelectViewAdapter.prototype, "ngrxFormControlState", {
            set: function (value) {
                if (!value) {
                    throw new Error('The control state must not be undefined!');
                }
                this.state = value;
                var nativeId = this.elementRef.nativeElement.id;
                var shouldSetNativeId = value.id !== nativeId && this.nativeIdWasSet;
                if (shouldSetNativeId) {
                    this.renderer.setProperty(this.elementRef.nativeElement, 'id', value.id);
                }
            },
            enumerable: false,
            configurable: true
        });
        NgrxSelectViewAdapter.prototype.ngAfterViewInit = function () {
            var nativeId = this.elementRef.nativeElement.id;
            var shouldSetNativeId = this.state.id !== nativeId && !nativeId;
            if (shouldSetNativeId) {
                this.renderer.setProperty(this.elementRef.nativeElement, 'id', this.state.id);
                this.nativeIdWasSet = true;
            }
        };
        NgrxSelectViewAdapter.prototype.setViewValue = function (value) {
            this.value = value;
            this.selectedId = this.getOptionId(value);
            if (this.selectedId === null) {
                this.renderer.setProperty(this.elementRef.nativeElement, 'selectedIndex', -1);
            }
            this.renderer.setProperty(this.elementRef.nativeElement, 'value', this.selectedId);
        };
        NgrxSelectViewAdapter.prototype.onChange = function (_a) {
            var target = _a.target;
            this.selectedId = target.value;
            var value = this.optionMap[this.selectedId];
            this.value = value;
            this.onChangeFn(value);
        };
        NgrxSelectViewAdapter.prototype.setOnChangeCallback = function (fn) {
            this.onChangeFn = fn;
        };
        NgrxSelectViewAdapter.prototype.setOnTouchedCallback = function (fn) {
            this.onTouched = fn;
        };
        NgrxSelectViewAdapter.prototype.setIsDisabled = function (isDisabled) {
            this.renderer.setProperty(this.elementRef.nativeElement, 'disabled', isDisabled);
        };
        NgrxSelectViewAdapter.prototype.createOptionId = function () {
            var id = this.idCounter.toString();
            this.idCounter += 1;
            return id;
        };
        NgrxSelectViewAdapter.prototype.updateOptionValue = function (id, value) {
            this.optionMap[id] = value;
            if (this.selectedId === id) {
                this.onChangeFn(value);
            }
            else if (value === this.value) {
                this.setViewValue(value);
            }
        };
        NgrxSelectViewAdapter.prototype.deregisterOption = function (id) {
            delete this.optionMap[id];
        };
        NgrxSelectViewAdapter.prototype.getOptionId = function (value) {
            var e_1, _a;
            try {
                for (var _b = __values(Array.from(Object.keys(this.optionMap))), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var id = _c.value;
                    if (this.optionMap[id] === value) {
                        return id;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return null;
        };
        return NgrxSelectViewAdapter;
    }());
    NgrxSelectViewAdapter.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0__namespace, type: NgrxSelectViewAdapter, deps: [{ token: i0__namespace.Renderer2 }, { token: i0__namespace.ElementRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    NgrxSelectViewAdapter.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.13", type: NgrxSelectViewAdapter, selector: "select:not([multiple])[ngrxFormControlState]", inputs: { ngrxFormControlState: "ngrxFormControlState" }, host: { listeners: { "blur": "onTouched()", "change": "onChange($event)" } }, providers: [{
                provide: NGRX_FORM_VIEW_ADAPTER,
                useExisting: i0.forwardRef(function () { return NgrxSelectViewAdapter; }),
                multi: true,
            }], ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0__namespace, type: NgrxSelectViewAdapter, decorators: [{
                type: i0.Directive,
                args: [{
                        // tslint:disable-next-line:directive-selector
                        selector: 'select:not([multiple])[ngrxFormControlState]',
                        providers: [{
                                provide: NGRX_FORM_VIEW_ADAPTER,
                                useExisting: i0.forwardRef(function () { return NgrxSelectViewAdapter; }),
                                multi: true,
                            }],
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.Renderer2 }, { type: i0__namespace.ElementRef }]; }, propDecorators: { onTouched: [{
                    type: i0.HostListener,
                    args: ['blur']
                }], ngrxFormControlState: [{
                    type: i0.Input
                }], onChange: [{
                    type: i0.HostListener,
                    args: ['change', ['$event']]
                }] } });
    var NULL_VIEW_ADAPTER$1 = {
        createOptionId: function () { return ''; },
        deregisterOption: function () { return void 0; },
        updateOptionValue: function () { return void 0; },
    };
    var NULL_RENDERER$2 = {
        setProperty: function () { return void 0; },
    };
    var NgrxSelectOption = /** @class */ (function () {
        function NgrxSelectOption(element, renderer, viewAdapter) {
            this.element = element;
            this.renderer = renderer;
            this.viewAdapter = viewAdapter;
            this.isInitialized = false;
            this.renderer = viewAdapter ? renderer : NULL_RENDERER$2;
            this.viewAdapter = viewAdapter || NULL_VIEW_ADAPTER$1;
            this.id = this.viewAdapter.createOptionId();
        }
        Object.defineProperty(NgrxSelectOption.prototype, "value", {
            set: function (value) {
                // this cannot be done inside ngOnInit since the value property
                // must be already set when the option value is updated in the view
                // adapter and the initial binding of 'value' happens before
                // ngOnInit runs
                if (!this.isInitialized) {
                    this.isInitialized = true;
                    this.renderer.setProperty(this.element.nativeElement, 'value', this.id);
                }
                this.viewAdapter.updateOptionValue(this.id, value);
            },
            enumerable: false,
            configurable: true
        });
        NgrxSelectOption.prototype.ngOnDestroy = function () {
            this.viewAdapter.deregisterOption(this.id);
        };
        return NgrxSelectOption;
    }());
    NgrxSelectOption.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0__namespace, type: NgrxSelectOption, deps: [{ token: i0__namespace.ElementRef }, { token: i0__namespace.Renderer2 }, { token: NgrxSelectViewAdapter, host: true, optional: true }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    NgrxSelectOption.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.13", type: NgrxSelectOption, selector: "option", inputs: { value: "value" }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0__namespace, type: NgrxSelectOption, decorators: [{
                type: i0.Directive,
                args: [{
                        // tslint:disable-next-line:directive-selector
                        selector: 'option',
                    }]
            }], ctorParameters: function () {
            return [{ type: i0__namespace.ElementRef }, { type: i0__namespace.Renderer2 }, { type: NgrxSelectViewAdapter, decorators: [{
                            type: i0.Host
                        }, {
                            type: i0.Optional
                        }] }];
        }, propDecorators: { value: [{
                    type: i0.Input,
                    args: ['value']
                }] } });

    // tslint:disable:directive-class-suffix
    var NgrxSelectMultipleViewAdapter = /** @class */ (function () {
        function NgrxSelectMultipleViewAdapter(renderer, elementRef) {
            this.renderer = renderer;
            this.elementRef = elementRef;
            this.options = {};
            this.optionValues = {};
            this.idCounter = 0;
            this.selectedIds = [];
            this.nativeIdWasSet = false;
            this.onChangeFn = function () { return void 0; };
            this.onTouched = function () { return void 0; };
        }
        Object.defineProperty(NgrxSelectMultipleViewAdapter.prototype, "ngrxFormControlState", {
            set: function (value) {
                if (!value) {
                    throw new Error('The control state must not be undefined!');
                }
                this.state = value;
                var nativeId = this.elementRef.nativeElement.id;
                var shouldSetNativeId = value.id !== nativeId && this.nativeIdWasSet;
                if (shouldSetNativeId) {
                    this.renderer.setProperty(this.elementRef.nativeElement, 'id', value.id);
                }
            },
            enumerable: false,
            configurable: true
        });
        NgrxSelectMultipleViewAdapter.prototype.ngAfterViewInit = function () {
            var nativeId = this.elementRef.nativeElement.id;
            var shouldSetNativeId = this.state.id !== nativeId && !nativeId;
            if (shouldSetNativeId) {
                this.renderer.setProperty(this.elementRef.nativeElement, 'id', this.state.id);
                this.nativeIdWasSet = true;
            }
        };
        NgrxSelectMultipleViewAdapter.prototype.setViewValue = function (value) {
            var _this = this;
            if (value === null) {
                value = [];
            }
            if (!Array.isArray(value)) {
                throw new Error("the value provided to a NgrxSelectMultipleViewAdapter must be null or an array; got " + value + " of type " + typeof value); // `
            }
            this.selectedIds = value.map(function (v) { return _this.getOptionId(v); }).filter(function (id) { return id !== null; }).map(function (id) { return id; });
            Object.keys(this.options).forEach(function (id) { return _this.options[id].isSelected = _this.selectedIds.indexOf(id) >= 0; });
        };
        NgrxSelectMultipleViewAdapter.prototype.onChange = function () {
            var _this = this;
            this.selectedIds = Object.keys(this.options).filter(function (id) { return _this.options[id].isSelected; });
            var value = this.selectedIds.map(function (id) { return _this.optionValues[id]; });
            this.onChangeFn(value);
        };
        NgrxSelectMultipleViewAdapter.prototype.setOnChangeCallback = function (fn) {
            this.onChangeFn = fn;
        };
        NgrxSelectMultipleViewAdapter.prototype.setOnTouchedCallback = function (fn) {
            this.onTouched = fn;
        };
        NgrxSelectMultipleViewAdapter.prototype.setIsDisabled = function (isDisabled) {
            this.renderer.setProperty(this.elementRef.nativeElement, 'disabled', isDisabled);
        };
        NgrxSelectMultipleViewAdapter.prototype.registerOption = function (option) {
            var id = this.idCounter.toString();
            this.options[id] = option;
            this.idCounter += 1;
            return id;
        };
        NgrxSelectMultipleViewAdapter.prototype.updateOptionValue = function (id, value) {
            this.optionValues[id] = value;
            if (this.selectedIds.indexOf(id) >= 0) {
                this.onChange();
            }
        };
        NgrxSelectMultipleViewAdapter.prototype.deregisterOption = function (id) {
            delete this.options[id];
            delete this.optionValues[id];
        };
        NgrxSelectMultipleViewAdapter.prototype.getOptionId = function (value) {
            var e_1, _a;
            try {
                for (var _b = __values(Array.from(Object.keys(this.optionValues))), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var id = _c.value;
                    if (this.optionValues[id] === value) {
                        return id;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return null;
        };
        return NgrxSelectMultipleViewAdapter;
    }());
    NgrxSelectMultipleViewAdapter.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0__namespace, type: NgrxSelectMultipleViewAdapter, deps: [{ token: i0__namespace.Renderer2 }, { token: i0__namespace.ElementRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    NgrxSelectMultipleViewAdapter.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.13", type: NgrxSelectMultipleViewAdapter, selector: "select[multiple][ngrxFormControlState]", inputs: { ngrxFormControlState: "ngrxFormControlState" }, host: { listeners: { "blur": "onTouched()", "change": "onChange()" } }, providers: [{
                provide: NGRX_FORM_VIEW_ADAPTER,
                useExisting: i0.forwardRef(function () { return NgrxSelectMultipleViewAdapter; }),
                multi: true,
            }], ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0__namespace, type: NgrxSelectMultipleViewAdapter, decorators: [{
                type: i0.Directive,
                args: [{
                        // tslint:disable-next-line:directive-selector
                        selector: 'select[multiple][ngrxFormControlState]',
                        providers: [{
                                provide: NGRX_FORM_VIEW_ADAPTER,
                                useExisting: i0.forwardRef(function () { return NgrxSelectMultipleViewAdapter; }),
                                multi: true,
                            }],
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.Renderer2 }, { type: i0__namespace.ElementRef }]; }, propDecorators: { onTouched: [{
                    type: i0.HostListener,
                    args: ['blur']
                }], ngrxFormControlState: [{
                    type: i0.Input
                }], onChange: [{
                    type: i0.HostListener,
                    args: ['change']
                }] } });
    var NULL_VIEW_ADAPTER = {
        registerOption: function () { return ''; },
        deregisterOption: function () { return void 0; },
        updateOptionValue: function () { return void 0; },
    };
    var NULL_RENDERER$1 = {
        setProperty: function () { return void 0; },
    };
    var NgrxSelectMultipleOption = /** @class */ (function () {
        function NgrxSelectMultipleOption(element, renderer, viewAdapter) {
            this.element = element;
            this.renderer = renderer;
            this.viewAdapter = viewAdapter;
            this.renderer = viewAdapter ? renderer : NULL_RENDERER$1;
            this.viewAdapter = viewAdapter || NULL_VIEW_ADAPTER;
            this.id = this.viewAdapter.registerOption(this);
        }
        Object.defineProperty(NgrxSelectMultipleOption.prototype, "value", {
            set: function (value) {
                this.viewAdapter.updateOptionValue(this.id, value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgrxSelectMultipleOption.prototype, "isSelected", {
            get: function () {
                return this.element.nativeElement.selected;
            },
            set: function (selected) {
                this.renderer.setProperty(this.element.nativeElement, 'selected', selected);
            },
            enumerable: false,
            configurable: true
        });
        NgrxSelectMultipleOption.prototype.ngOnInit = function () {
            this.renderer.setProperty(this.element.nativeElement, 'value', this.id);
        };
        NgrxSelectMultipleOption.prototype.ngOnDestroy = function () {
            this.viewAdapter.deregisterOption(this.id);
        };
        return NgrxSelectMultipleOption;
    }());
    NgrxSelectMultipleOption.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0__namespace, type: NgrxSelectMultipleOption, deps: [{ token: i0__namespace.ElementRef }, { token: i0__namespace.Renderer2 }, { token: NgrxSelectMultipleViewAdapter, host: true, optional: true }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    NgrxSelectMultipleOption.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.13", type: NgrxSelectMultipleOption, selector: "option", inputs: { value: "value" }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0__namespace, type: NgrxSelectMultipleOption, decorators: [{
                type: i0.Directive,
                args: [{
                        // tslint:disable-next-line:directive-selector
                        selector: 'option',
                    }]
            }], ctorParameters: function () {
            return [{ type: i0__namespace.ElementRef }, { type: i0__namespace.Renderer2 }, { type: NgrxSelectMultipleViewAdapter, decorators: [{
                            type: i0.Host
                        }, {
                            type: i0.Optional
                        }] }];
        }, propDecorators: { value: [{
                    type: i0.Input,
                    args: ['value']
                }] } });

    // tslint:disable:directive-class-suffix
    var NULL_RENDERER = {
        setProperty: function () { return void 0; },
    };
    /**
     * This directive is necessary to restore the default behaviour of Angular
     * when an `option` is used without an **ngrx-forms** form state. Since it
     * is not possible to select an element with a selector that considers its
     * parent the `option` directives for `select` and `select[multiple]` will
     * always be applied and therefore overriding the `[value]` binding which
     * disabled Angular's normal behaviour. This directive restores this
     * behaviour if no `select` or `select[multiple]` view adapter is found.
     * This is not a perfect solution since it may interfere with other
     * directives that try to set the `[value]` but that is very unlikely.
     */
    var NgrxFallbackSelectOption = /** @class */ (function () {
        function NgrxFallbackSelectOption(element, renderer, viewAdapter, multipleViewAdapter) {
            this.element = element;
            this.renderer = renderer;
            this.renderer = viewAdapter || multipleViewAdapter ? NULL_RENDERER : renderer;
        }
        Object.defineProperty(NgrxFallbackSelectOption.prototype, "value", {
            set: function (value) {
                this.renderer.setProperty(this.element.nativeElement, 'value', value);
            },
            enumerable: false,
            configurable: true
        });
        return NgrxFallbackSelectOption;
    }());
    NgrxFallbackSelectOption.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0__namespace, type: NgrxFallbackSelectOption, deps: [{ token: i0__namespace.ElementRef }, { token: i0__namespace.Renderer2 }, { token: NgrxSelectViewAdapter, host: true, optional: true }, { token: NgrxSelectMultipleViewAdapter, host: true, optional: true }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    NgrxFallbackSelectOption.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.13", type: NgrxFallbackSelectOption, selector: "option", inputs: { value: "value" }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0__namespace, type: NgrxFallbackSelectOption, decorators: [{
                type: i0.Directive,
                args: [{
                        // tslint:disable-next-line:directive-selector
                        selector: 'option',
                    }]
            }], ctorParameters: function () {
            return [{ type: i0__namespace.ElementRef }, { type: i0__namespace.Renderer2 }, { type: NgrxSelectViewAdapter, decorators: [{
                            type: i0.Host
                        }, {
                            type: i0.Optional
                        }] }, { type: NgrxSelectMultipleViewAdapter, decorators: [{
                            type: i0.Host
                        }, {
                            type: i0.Optional
                        }] }];
        }, propDecorators: { value: [{
                    type: i0.Input,
                    args: ['value']
                }] } });

    // tslint:disable:directive-class-suffix
    var NgrxRadioViewAdapter = /** @class */ (function () {
        function NgrxRadioViewAdapter(renderer, elementRef) {
            this.renderer = renderer;
            this.elementRef = elementRef;
            this.nativeNameWasSet = false;
            this.onChange = function () { return void 0; };
            this.onTouched = function () { return void 0; };
        }
        Object.defineProperty(NgrxRadioViewAdapter.prototype, "value", {
            set: function (val) {
                if (val !== this.latestValue) {
                    this.latestValue = val;
                    if (this.isChecked) {
                        this.onChange();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgrxRadioViewAdapter.prototype, "ngrxFormControlState", {
            set: function (value) {
                if (!value) {
                    throw new Error('The control state must not be undefined!');
                }
                this.state = value;
                var nativeName = this.elementRef.nativeElement.name;
                var shouldSetNativeName = value.id !== nativeName && this.nativeNameWasSet;
                if (shouldSetNativeName) {
                    this.renderer.setProperty(this.elementRef.nativeElement, 'name', value.id);
                }
            },
            enumerable: false,
            configurable: true
        });
        NgrxRadioViewAdapter.prototype.ngOnInit = function () {
            this.isChecked = this.elementRef.nativeElement.checked;
        };
        NgrxRadioViewAdapter.prototype.ngAfterViewInit = function () {
            var nativeName = this.elementRef.nativeElement.name;
            var shouldSetNativeName = this.state.id !== nativeName && !nativeName;
            if (shouldSetNativeName) {
                this.renderer.setProperty(this.elementRef.nativeElement, 'name', this.state.id);
                this.nativeNameWasSet = true;
            }
        };
        NgrxRadioViewAdapter.prototype.setViewValue = function (value) {
            this.isChecked = value === this.latestValue;
            this.renderer.setProperty(this.elementRef.nativeElement, 'checked', this.isChecked);
        };
        NgrxRadioViewAdapter.prototype.setOnChangeCallback = function (fn) {
            var _this = this;
            this.onChange = function () { return fn(_this.latestValue); };
        };
        NgrxRadioViewAdapter.prototype.setOnTouchedCallback = function (fn) {
            this.onTouched = fn;
        };
        NgrxRadioViewAdapter.prototype.setIsDisabled = function (isDisabled) {
            this.renderer.setProperty(this.elementRef.nativeElement, 'disabled', isDisabled);
        };
        return NgrxRadioViewAdapter;
    }());
    NgrxRadioViewAdapter.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0__namespace, type: NgrxRadioViewAdapter, deps: [{ token: i0__namespace.Renderer2 }, { token: i0__namespace.ElementRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    NgrxRadioViewAdapter.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.13", type: NgrxRadioViewAdapter, selector: "input[type=radio][ngrxFormControlState]", inputs: { value: "value", ngrxFormControlState: "ngrxFormControlState" }, host: { listeners: { "change": "onChange()", "blur": "onTouched()" } }, providers: [{
                provide: NGRX_FORM_VIEW_ADAPTER,
                useExisting: i0.forwardRef(function () { return NgrxRadioViewAdapter; }),
                multi: true,
            }], ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0__namespace, type: NgrxRadioViewAdapter, decorators: [{
                type: i0.Directive,
                args: [{
                        // tslint:disable-next-line:directive-selector
                        selector: 'input[type=radio][ngrxFormControlState]',
                        providers: [{
                                provide: NGRX_FORM_VIEW_ADAPTER,
                                useExisting: i0.forwardRef(function () { return NgrxRadioViewAdapter; }),
                                multi: true,
                            }],
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.Renderer2 }, { type: i0__namespace.ElementRef }]; }, propDecorators: { value: [{
                    type: i0.Input
                }], ngrxFormControlState: [{
                    type: i0.Input
                }], onChange: [{
                    type: i0.HostListener,
                    args: ['change']
                }], onTouched: [{
                    type: i0.HostListener,
                    args: ['blur']
                }] } });

    // tslint:disable:directive-class-suffix
    var NgrxRangeViewAdapter = /** @class */ (function () {
        function NgrxRangeViewAdapter(renderer, elementRef) {
            this.renderer = renderer;
            this.elementRef = elementRef;
            this.nativeIdWasSet = false;
            this.onChange = function () { return void 0; };
            this.onTouched = function () { return void 0; };
        }
        Object.defineProperty(NgrxRangeViewAdapter.prototype, "ngrxFormControlState", {
            set: function (value) {
                if (!value) {
                    throw new Error('The control state must not be undefined!');
                }
                this.state = value;
                var nativeId = this.elementRef.nativeElement.id;
                var shouldSetNativeId = value.id !== nativeId && this.nativeIdWasSet;
                if (shouldSetNativeId) {
                    this.renderer.setProperty(this.elementRef.nativeElement, 'id', value.id);
                }
            },
            enumerable: false,
            configurable: true
        });
        NgrxRangeViewAdapter.prototype.ngAfterViewInit = function () {
            var nativeId = this.elementRef.nativeElement.id;
            var shouldSetNativeId = this.state.id !== nativeId && !nativeId;
            if (shouldSetNativeId) {
                this.renderer.setProperty(this.elementRef.nativeElement, 'id', this.state.id);
                this.nativeIdWasSet = true;
            }
        };
        NgrxRangeViewAdapter.prototype.setViewValue = function (value) {
            this.renderer.setProperty(this.elementRef.nativeElement, 'value', parseFloat(value));
        };
        NgrxRangeViewAdapter.prototype.setOnChangeCallback = function (fn) {
            this.onChange = fn;
        };
        NgrxRangeViewAdapter.prototype.setOnTouchedCallback = function (fn) {
            this.onTouched = fn;
        };
        NgrxRangeViewAdapter.prototype.setIsDisabled = function (isDisabled) {
            this.renderer.setProperty(this.elementRef.nativeElement, 'disabled', isDisabled);
        };
        NgrxRangeViewAdapter.prototype.handleInput = function (_a) {
            var target = _a.target;
            var value = target.value;
            this.onChange(value === '' ? null : parseFloat(value));
        };
        return NgrxRangeViewAdapter;
    }());
    NgrxRangeViewAdapter.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0__namespace, type: NgrxRangeViewAdapter, deps: [{ token: i0__namespace.Renderer2 }, { token: i0__namespace.ElementRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    NgrxRangeViewAdapter.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.13", type: NgrxRangeViewAdapter, selector: "input[type=range][ngrxFormControlState]", inputs: { ngrxFormControlState: "ngrxFormControlState" }, host: { listeners: { "blur": "onTouched()", "change": "handleInput($event)", "input": "handleInput($event)" } }, providers: [{
                provide: NGRX_FORM_VIEW_ADAPTER,
                useExisting: i0.forwardRef(function () { return NgrxRangeViewAdapter; }),
                multi: true,
            }], ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0__namespace, type: NgrxRangeViewAdapter, decorators: [{
                type: i0.Directive,
                args: [{
                        // tslint:disable-next-line:directive-selector
                        selector: 'input[type=range][ngrxFormControlState]',
                        providers: [{
                                provide: NGRX_FORM_VIEW_ADAPTER,
                                useExisting: i0.forwardRef(function () { return NgrxRangeViewAdapter; }),
                                multi: true,
                            }],
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.Renderer2 }, { type: i0__namespace.ElementRef }]; }, propDecorators: { onTouched: [{
                    type: i0.HostListener,
                    args: ['blur']
                }], ngrxFormControlState: [{
                    type: i0.Input
                }], handleInput: [{
                    type: i0.HostListener,
                    args: ['change', ['$event']]
                }, {
                    type: i0.HostListener,
                    args: ['input', ['$event']]
                }] } });

    var BUILTIN_ADAPTERS = [
        NgrxCheckboxViewAdapter,
        NgrxRangeViewAdapter,
        NgrxNumberViewAdapter,
        NgrxSelectViewAdapter,
        NgrxSelectMultipleViewAdapter,
        NgrxRadioViewAdapter,
    ];
    function isBuiltInViewAdapter(viewAdapter) {
        return BUILTIN_ADAPTERS.some(function (a) { return viewAdapter.constructor === a; });
    }
    function selectViewAdapter(viewAdapters) {
        if (!viewAdapters) {
            throw new Error('No view adapter matches!');
        }
        var defaultAdapter;
        var builtinAdapter;
        var customAdapter;
        viewAdapters.forEach(function (v) {
            if (v.constructor === NgrxDefaultViewAdapter) {
                defaultAdapter = v;
            }
            else if (isBuiltInViewAdapter(v)) {
                if (builtinAdapter) {
                    throw new Error('More than one built-in view adapter matches!');
                }
                builtinAdapter = v;
            }
            else {
                if (customAdapter) {
                    throw new Error('More than one custom view adapter matches!');
                }
                customAdapter = v;
            }
        });
        if (customAdapter) {
            return customAdapter;
        }
        if (builtinAdapter) {
            return builtinAdapter;
        }
        if (defaultAdapter) {
            return defaultAdapter;
        }
        throw new Error('No valid view adapter!');
    }

    // tslint:disable-next-line:variable-name
    var NgrxValueConverters = {
        default: function () {
            return {
                convertViewToStateValue: function (value) { return typeof value === 'object' && value !== null ? box(value) : value; },
                convertStateToViewValue: unbox,
            };
        },
        dateToISOString: {
            convertViewToStateValue: function (date) { return date === null ? null : date.toISOString(); },
            convertStateToViewValue: function (s) { return s === null ? null : new Date(Date.parse(s)); },
        },
        objectToJSON: {
            convertViewToStateValue: function (value) { return value === null ? null : JSON.stringify(value); },
            convertStateToViewValue: function (s) { return s === null ? null : JSON.parse(s); },
        },
    };

    exports.NGRX_UPDATE_ON_TYPE = void 0;
    (function (NGRX_UPDATE_ON_TYPE) {
        NGRX_UPDATE_ON_TYPE["CHANGE"] = "change";
        NGRX_UPDATE_ON_TYPE["BLUR"] = "blur";
        NGRX_UPDATE_ON_TYPE["NEVER"] = "never";
    })(exports.NGRX_UPDATE_ON_TYPE || (exports.NGRX_UPDATE_ON_TYPE = {}));
    var ControlValueAccessorAdapter = /** @class */ (function () {
        function ControlValueAccessorAdapter(valueAccessor) {
            this.valueAccessor = valueAccessor;
        }
        ControlValueAccessorAdapter.prototype.setViewValue = function (value) {
            this.valueAccessor.writeValue(value);
        };
        ControlValueAccessorAdapter.prototype.setOnChangeCallback = function (fn) {
            this.valueAccessor.registerOnChange(fn);
        };
        ControlValueAccessorAdapter.prototype.setOnTouchedCallback = function (fn) {
            this.valueAccessor.registerOnTouched(fn);
        };
        ControlValueAccessorAdapter.prototype.setIsDisabled = function (isDisabled) {
            if (this.valueAccessor.setDisabledState) {
                this.valueAccessor.setDisabledState(isDisabled);
            }
        };
        return ControlValueAccessorAdapter;
    }());
    var NgrxFormControlDirective = /** @class */ (function () {
        function NgrxFormControlDirective(el, 
        // for the dom parameter the `null` type must be last to ensure that in the compiled output
        // there is no reference to the Document type to support non-browser platforms
        dom, actionsSubject, viewAdapters, valueAccessors) {
            this.el = el;
            this.dom = dom;
            this.actionsSubject = actionsSubject;
            this.isInitialized = false;
            this.focusTrackingIsEnabled = false;
            this.ngrxUpdateOn = exports.NGRX_UPDATE_ON_TYPE.CHANGE;
            this.ngrxValueConverter = NgrxValueConverters.default();
            viewAdapters = viewAdapters || [];
            valueAccessors = valueAccessors || [];
            if (valueAccessors.length > 1) {
                throw new Error('More than one custom control value accessor matches!');
            }
            this.viewAdapter = valueAccessors.length > 0
                ? new ControlValueAccessorAdapter(valueAccessors[0])
                : selectViewAdapter(viewAdapters);
        }
        Object.defineProperty(NgrxFormControlDirective.prototype, "ngrxFormControlState", {
            set: function (newState) {
                if (!newState) {
                    throw new Error('The control state must not be undefined!');
                }
                var oldState = this.state;
                this.state = newState;
                if (this.isInitialized) {
                    this.updateViewIfControlIdChanged(newState, oldState);
                    this.updateViewIfValueChanged(newState, oldState);
                    this.updateViewIfIsDisabledChanged(newState, oldState);
                    this.updateViewIfIsFocusedChanged(newState, oldState);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgrxFormControlDirective.prototype, "ngrxEnableFocusTracking", {
            set: function (value) {
                if (value && !this.dom) {
                    throw new Error('focus tracking is only supported on the browser platform');
                }
                this.focusTrackingIsEnabled = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgrxFormControlDirective.prototype, "focusRegionStartAttr", {
            // TODO: move this into a separate directive
            // automatically apply the attribute that's used by the CDK to set initial focus
            get: function () {
                return this.state && this.state.isFocused ? '' : null;
            },
            enumerable: false,
            configurable: true
        });
        NgrxFormControlDirective.prototype.updateViewIfControlIdChanged = function (newState, oldState) {
            if (oldState && newState.id === oldState.id) {
                return;
            }
            this.stateValue = newState.value;
            this.viewValue = this.ngrxValueConverter.convertStateToViewValue(this.stateValue);
            this.viewAdapter.setViewValue(this.viewValue);
            if (this.viewAdapter.setIsDisabled) {
                this.viewAdapter.setIsDisabled(newState.isDisabled);
            }
        };
        NgrxFormControlDirective.prototype.updateViewIfValueChanged = function (newState, _) {
            if (newState.value === this.stateValue) {
                return;
            }
            this.stateValue = newState.value;
            this.viewValue = this.ngrxValueConverter.convertStateToViewValue(newState.value);
            this.viewAdapter.setViewValue(this.viewValue);
        };
        NgrxFormControlDirective.prototype.updateViewIfIsDisabledChanged = function (newState, oldState) {
            if (!this.viewAdapter.setIsDisabled) {
                return;
            }
            if (oldState && newState.isDisabled === oldState.isDisabled) {
                return;
            }
            this.viewAdapter.setIsDisabled(newState.isDisabled);
        };
        NgrxFormControlDirective.prototype.updateViewIfIsFocusedChanged = function (newState, oldState) {
            if (!this.focusTrackingIsEnabled) {
                return;
            }
            if (oldState && newState.isFocused === oldState.isFocused) {
                return;
            }
            if (newState.isFocused) {
                this.el.nativeElement.focus();
            }
            else {
                this.el.nativeElement.blur();
            }
        };
        NgrxFormControlDirective.prototype.dispatchAction = function (action) {
            if (this.actionsSubject !== null) {
                this.actionsSubject.next(action);
            }
            else {
                throw new Error('ActionsSubject must be present in order to dispatch actions!');
            }
        };
        NgrxFormControlDirective.prototype.ngOnInit = function () {
            var _this = this;
            if (!this.state) {
                throw new Error('The form state must not be undefined!');
            }
            this.isInitialized = true;
            this.updateViewIfControlIdChanged(this.state, undefined);
            this.updateViewIfValueChanged(this.state, undefined);
            this.updateViewIfIsDisabledChanged(this.state, undefined);
            this.updateViewIfIsFocusedChanged(this.state, undefined);
            var dispatchMarkAsDirtyAction = function () {
                if (_this.state.isPristine) {
                    _this.dispatchAction(new MarkAsDirtyAction(_this.state.id));
                }
            };
            var dispatchSetValueAction = function () {
                _this.stateValue = _this.ngrxValueConverter.convertViewToStateValue(_this.viewValue);
                if (_this.stateValue !== _this.state.value) {
                    _this.dispatchAction(new SetValueAction(_this.state.id, _this.stateValue));
                    dispatchMarkAsDirtyAction();
                }
            };
            this.viewAdapter.setOnChangeCallback(function (viewValue) {
                _this.viewValue = viewValue;
                if (_this.ngrxUpdateOn === exports.NGRX_UPDATE_ON_TYPE.CHANGE) {
                    dispatchSetValueAction();
                }
            });
            this.viewAdapter.setOnTouchedCallback(function () {
                if (!_this.state.isTouched && _this.ngrxUpdateOn !== exports.NGRX_UPDATE_ON_TYPE.NEVER) {
                    _this.dispatchAction(new MarkAsTouchedAction(_this.state.id));
                }
                if (_this.ngrxUpdateOn === exports.NGRX_UPDATE_ON_TYPE.BLUR) {
                    dispatchSetValueAction();
                }
            });
        };
        NgrxFormControlDirective.prototype.ngAfterViewInit = function () {
            // we need to update the view again after it was initialized since some
            // controls depend on child elements for setting the value (e.g. selects)
            this.viewAdapter.setViewValue(this.viewValue);
            if (this.viewAdapter.setIsDisabled) {
                this.viewAdapter.setIsDisabled(this.state.isDisabled);
            }
        };
        NgrxFormControlDirective.prototype.onFocusChange = function () {
            if (!this.focusTrackingIsEnabled) {
                return;
            }
            var isControlFocused = this.el.nativeElement === this.dom.activeElement;
            if (isControlFocused !== this.state.isFocused) {
                this.dispatchAction(isControlFocused ? new FocusAction(this.state.id) : new UnfocusAction(this.state.id));
            }
        };
        return NgrxFormControlDirective;
    }());
    NgrxFormControlDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0__namespace, type: NgrxFormControlDirective, deps: [{ token: i0__namespace.ElementRef }, { token: common.DOCUMENT, optional: true }, { token: i1.ActionsSubject, optional: true }, { token: NGRX_FORM_VIEW_ADAPTER, optional: true, self: true }, { token: forms.NG_VALUE_ACCESSOR, optional: true, self: true }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    NgrxFormControlDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.13", type: NgrxFormControlDirective, selector: ":not([ngrxFormsAction])[ngrxFormControlState]", inputs: { ngrxFormControlState: "ngrxFormControlState", ngrxUpdateOn: "ngrxUpdateOn", ngrxEnableFocusTracking: "ngrxEnableFocusTracking", ngrxValueConverter: "ngrxValueConverter" }, host: { listeners: { "focusin": "onFocusChange()", "focusout": "onFocusChange()" }, properties: { "attr.cdk-focus-region-start": "this.focusRegionStartAttr" } }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0__namespace, type: NgrxFormControlDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        // tslint:disable-next-line:directive-selector
                        selector: ':not([ngrxFormsAction])[ngrxFormControlState]',
                    }]
            }], ctorParameters: function () {
            return [{ type: i0__namespace.ElementRef }, { type: undefined, decorators: [{
                            type: i0.Optional
                        }, {
                            type: i0.Inject,
                            args: [common.DOCUMENT]
                        }] }, { type: i1__namespace.ActionsSubject, decorators: [{
                            type: i0.Optional
                        }, {
                            type: i0.Inject,
                            args: [i1.ActionsSubject]
                        }] }, { type: undefined, decorators: [{
                            type: i0.Self
                        }, {
                            type: i0.Optional
                        }, {
                            type: i0.Inject,
                            args: [NGRX_FORM_VIEW_ADAPTER]
                        }] }, { type: undefined, decorators: [{
                            type: i0.Self
                        }, {
                            type: i0.Optional
                        }, {
                            type: i0.Inject,
                            args: [forms.NG_VALUE_ACCESSOR]
                        }] }];
        }, propDecorators: { ngrxFormControlState: [{
                    type: i0.Input
                }], ngrxUpdateOn: [{
                    type: i0.Input
                }], ngrxEnableFocusTracking: [{
                    type: i0.Input
                }], ngrxValueConverter: [{
                    type: i0.Input
                }], focusRegionStartAttr: [{
                    type: i0.HostBinding,
                    args: ['attr.cdk-focus-region-start']
                }], onFocusChange: [{
                    type: i0.HostListener,
                    args: ['focusin']
                }, {
                    type: i0.HostListener,
                    args: ['focusout']
                }] } });

    var NgrxLocalFormControlDirective = /** @class */ (function (_super) {
        __extends(NgrxLocalFormControlDirective, _super);
        function NgrxLocalFormControlDirective(el, dom, viewAdapters, valueAccessors) {
            var _this = _super.call(this, el, dom, null, viewAdapters, valueAccessors) || this;
            _this.ngrxFormsAction = new i0.EventEmitter();
            return _this;
        }
        NgrxLocalFormControlDirective.prototype.dispatchAction = function (action) {
            this.ngrxFormsAction.emit(action);
        };
        return NgrxLocalFormControlDirective;
    }(NgrxFormControlDirective));
    NgrxLocalFormControlDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0__namespace, type: NgrxLocalFormControlDirective, deps: [{ token: i0__namespace.ElementRef }, { token: common.DOCUMENT, optional: true }, { token: NGRX_FORM_VIEW_ADAPTER, optional: true, self: true }, { token: forms.NG_VALUE_ACCESSOR, optional: true, self: true }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    NgrxLocalFormControlDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.13", type: NgrxLocalFormControlDirective, selector: "[ngrxFormControlState][ngrxFormsAction]", outputs: { ngrxFormsAction: "ngrxFormsAction" }, usesInheritance: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0__namespace, type: NgrxLocalFormControlDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        // tslint:disable-next-line:directive-selector
                        selector: '[ngrxFormControlState][ngrxFormsAction]',
                    }]
            }], ctorParameters: function () {
            return [{ type: i0__namespace.ElementRef }, { type: undefined, decorators: [{
                            type: i0.Optional
                        }, {
                            type: i0.Inject,
                            args: [common.DOCUMENT]
                        }] }, { type: undefined, decorators: [{
                            type: i0.Self
                        }, {
                            type: i0.Optional
                        }, {
                            type: i0.Inject,
                            args: [NGRX_FORM_VIEW_ADAPTER]
                        }] }, { type: undefined, decorators: [{
                            type: i0.Self
                        }, {
                            type: i0.Optional
                        }, {
                            type: i0.Inject,
                            args: [forms.NG_VALUE_ACCESSOR]
                        }] }];
        }, propDecorators: { ngrxFormsAction: [{
                    type: i0.Output
                }] } });

    var NgrxFormDirective = /** @class */ (function () {
        function NgrxFormDirective(actionsSubject) {
            this.actionsSubject = actionsSubject;
            this.actionsSubject = actionsSubject;
        }
        NgrxFormDirective.prototype.dispatchAction = function (action) {
            if (this.actionsSubject !== null) {
                this.actionsSubject.next(action);
            }
            else {
                throw new Error('ActionsSubject must be present in order to dispatch actions!');
            }
        };
        NgrxFormDirective.prototype.ngOnInit = function () {
            if (!this.state) {
                throw new Error('The form state must not be undefined!');
            }
        };
        NgrxFormDirective.prototype.onSubmit = function (event) {
            event.preventDefault();
            if (this.state.isUnsubmitted) {
                this.dispatchAction(new MarkAsSubmittedAction(this.state.id));
            }
        };
        return NgrxFormDirective;
    }());
    NgrxFormDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0__namespace, type: NgrxFormDirective, deps: [{ token: i1.ActionsSubject, optional: true }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    NgrxFormDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.13", type: NgrxFormDirective, selector: "form:not([ngrxFormsAction])[ngrxFormState]", inputs: { state: ["ngrxFormState", "state"] }, host: { listeners: { "submit": "onSubmit($event)" } }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0__namespace, type: NgrxFormDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        // tslint:disable-next-line:directive-selector
                        selector: 'form:not([ngrxFormsAction])[ngrxFormState]',
                    }]
            }], ctorParameters: function () {
            return [{ type: i1__namespace.ActionsSubject, decorators: [{
                            type: i0.Optional
                        }, {
                            type: i0.Inject,
                            args: [i1.ActionsSubject]
                        }] }];
        }, propDecorators: { state: [{
                    type: i0.Input,
                    args: ['ngrxFormState']
                }], onSubmit: [{
                    type: i0.HostListener,
                    args: ['submit', ['$event']]
                }] } });

    var NgrxLocalFormDirective = /** @class */ (function (_super) {
        __extends(NgrxLocalFormDirective, _super);
        function NgrxLocalFormDirective() {
            var _this = _super.call(this, null) || this;
            _this.ngrxFormsAction = new i0.EventEmitter();
            return _this;
        }
        NgrxLocalFormDirective.prototype.dispatchAction = function (action) {
            this.ngrxFormsAction.emit(action);
        };
        return NgrxLocalFormDirective;
    }(NgrxFormDirective));
    NgrxLocalFormDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0__namespace, type: NgrxLocalFormDirective, deps: [], target: i0__namespace.ɵɵFactoryTarget.Directive });
    NgrxLocalFormDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.13", type: NgrxLocalFormDirective, selector: "form[ngrxFormState][ngrxFormsAction]", outputs: { ngrxFormsAction: "ngrxFormsAction" }, usesInheritance: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0__namespace, type: NgrxLocalFormDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        // tslint:disable-next-line:directive-selector
                        selector: 'form[ngrxFormState][ngrxFormsAction]',
                    }]
            }], ctorParameters: function () { return []; }, propDecorators: { ngrxFormsAction: [{
                    type: i0.Output
                }] } });

    /**
     * Lists the available status class names based on the property
     * they are depending on.
     */
    var NGRX_STATUS_CLASS_NAMES = {
        isValid: 'ngrx-forms-valid',
        isInvalid: 'ngrx-forms-invalid',
        isDirty: 'ngrx-forms-dirty',
        isPristine: 'ngrx-forms-pristine',
        isTouched: 'ngrx-forms-touched',
        isUntouched: 'ngrx-forms-untouched',
        isSubmitted: 'ngrx-forms-submitted',
        isUnsubmitted: 'ngrx-forms-unsubmitted',
        isValidationPending: 'ngrx-forms-validation-pending',
    };
    var NgrxStatusCssClassesDirective = /** @class */ (function () {
        function NgrxStatusCssClassesDirective() {
        }
        Object.defineProperty(NgrxStatusCssClassesDirective.prototype, "ngrxFormControlState", {
            set: function (state) {
                this.state = state;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgrxStatusCssClassesDirective.prototype, "ngrxFormState", {
            set: function (state) {
                this.state = state;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgrxStatusCssClassesDirective.prototype, "isValid", {
            get: function () {
                return this.state.isValid;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgrxStatusCssClassesDirective.prototype, "isInvalid", {
            get: function () {
                return this.state.isInvalid;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgrxStatusCssClassesDirective.prototype, "isDirty", {
            get: function () {
                return this.state.isDirty;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgrxStatusCssClassesDirective.prototype, "isPristine", {
            get: function () {
                return this.state.isPristine;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgrxStatusCssClassesDirective.prototype, "isTouched", {
            get: function () {
                return this.state.isTouched;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgrxStatusCssClassesDirective.prototype, "isUntouched", {
            get: function () {
                return this.state.isUntouched;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgrxStatusCssClassesDirective.prototype, "isSubmitted", {
            get: function () {
                return this.state.isSubmitted;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgrxStatusCssClassesDirective.prototype, "isUnsubmitted", {
            get: function () {
                return this.state.isUnsubmitted;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgrxStatusCssClassesDirective.prototype, "isValidationPending", {
            get: function () {
                return this.state.isValidationPending;
            },
            enumerable: false,
            configurable: true
        });
        return NgrxStatusCssClassesDirective;
    }());
    NgrxStatusCssClassesDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0__namespace, type: NgrxStatusCssClassesDirective, deps: [], target: i0__namespace.ɵɵFactoryTarget.Directive });
    NgrxStatusCssClassesDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.13", type: NgrxStatusCssClassesDirective, selector: "form[ngrxFormState],[ngrxFormControlState]", inputs: { ngrxFormControlState: "ngrxFormControlState", ngrxFormState: "ngrxFormState" }, host: { properties: { "class.ngrx-forms-valid": "this.isValid", "class.ngrx-forms-invalid": "this.isInvalid", "class.ngrx-forms-dirty": "this.isDirty", "class.ngrx-forms-pristine": "this.isPristine", "class.ngrx-forms-touched": "this.isTouched", "class.ngrx-forms-untouched": "this.isUntouched", "class.ngrx-forms-submitted": "this.isSubmitted", "class.ngrx-forms-unsubmitted": "this.isUnsubmitted", "class.ngrx-forms-validation-pending": "this.isValidationPending" } }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0__namespace, type: NgrxStatusCssClassesDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        // tslint:disable-next-line:directive-selector
                        selector: 'form[ngrxFormState],[ngrxFormControlState]',
                    }]
            }], propDecorators: { ngrxFormControlState: [{
                    type: i0.Input
                }], ngrxFormState: [{
                    type: i0.Input
                }], isValid: [{
                    type: i0.HostBinding,
                    args: ["class." + NGRX_STATUS_CLASS_NAMES.isValid]
                }], isInvalid: [{
                    type: i0.HostBinding,
                    args: ["class." + NGRX_STATUS_CLASS_NAMES.isInvalid]
                }], isDirty: [{
                    type: i0.HostBinding,
                    args: ["class." + NGRX_STATUS_CLASS_NAMES.isDirty]
                }], isPristine: [{
                    type: i0.HostBinding,
                    args: ["class." + NGRX_STATUS_CLASS_NAMES.isPristine]
                }], isTouched: [{
                    type: i0.HostBinding,
                    args: ["class." + NGRX_STATUS_CLASS_NAMES.isTouched]
                }], isUntouched: [{
                    type: i0.HostBinding,
                    args: ["class." + NGRX_STATUS_CLASS_NAMES.isUntouched]
                }], isSubmitted: [{
                    type: i0.HostBinding,
                    args: ["class." + NGRX_STATUS_CLASS_NAMES.isSubmitted]
                }], isUnsubmitted: [{
                    type: i0.HostBinding,
                    args: ["class." + NGRX_STATUS_CLASS_NAMES.isUnsubmitted]
                }], isValidationPending: [{
                    type: i0.HostBinding,
                    args: ["class." + NGRX_STATUS_CLASS_NAMES.isValidationPending]
                }] } });

    var exportsAndDeclarations = [
        NgrxFormControlDirective,
        NgrxLocalFormControlDirective,
        NgrxFormDirective,
        NgrxLocalFormDirective,
        NgrxCheckboxViewAdapter,
        NgrxDefaultViewAdapter,
        NgrxNumberViewAdapter,
        NgrxRadioViewAdapter,
        NgrxRangeViewAdapter,
        NgrxSelectMultipleOption,
        NgrxSelectMultipleViewAdapter,
        NgrxSelectOption,
        NgrxSelectViewAdapter,
        NgrxFallbackSelectOption,
        NgrxStatusCssClassesDirective,
    ];
    var NgrxFormsModule = /** @class */ (function () {
        function NgrxFormsModule() {
        }
        return NgrxFormsModule;
    }());
    NgrxFormsModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0__namespace, type: NgrxFormsModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    NgrxFormsModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0__namespace, type: NgrxFormsModule, declarations: [NgrxFormControlDirective,
            NgrxLocalFormControlDirective,
            NgrxFormDirective,
            NgrxLocalFormDirective,
            NgrxCheckboxViewAdapter,
            NgrxDefaultViewAdapter,
            NgrxNumberViewAdapter,
            NgrxRadioViewAdapter,
            NgrxRangeViewAdapter,
            NgrxSelectMultipleOption,
            NgrxSelectMultipleViewAdapter,
            NgrxSelectOption,
            NgrxSelectViewAdapter,
            NgrxFallbackSelectOption,
            NgrxStatusCssClassesDirective], exports: [NgrxFormControlDirective,
            NgrxLocalFormControlDirective,
            NgrxFormDirective,
            NgrxLocalFormDirective,
            NgrxCheckboxViewAdapter,
            NgrxDefaultViewAdapter,
            NgrxNumberViewAdapter,
            NgrxRadioViewAdapter,
            NgrxRangeViewAdapter,
            NgrxSelectMultipleOption,
            NgrxSelectMultipleViewAdapter,
            NgrxSelectOption,
            NgrxSelectViewAdapter,
            NgrxFallbackSelectOption,
            NgrxStatusCssClassesDirective] });
    NgrxFormsModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0__namespace, type: NgrxFormsModule });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0__namespace, type: NgrxFormsModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        declarations: exportsAndDeclarations,
                        exports: exportsAndDeclarations,
                    }]
            }] });

    /**
     * ngrx-forms
     * Proper integration of forms in Angular applications using Ngrx
     * Written by Jonathan Ziller.
     * MIT license.
     * https://github.com/MrWolfZ/ngrx-forms
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.ALL_NGRX_FORMS_ACTION_TYPES = ALL_NGRX_FORMS_ACTION_TYPES;
    exports.AddArrayControlAction = AddArrayControlAction;
    exports.AddGroupControlAction = AddGroupControlAction;
    exports.ClearAsyncErrorAction = ClearAsyncErrorAction;
    exports.DisableAction = DisableAction;
    exports.EnableAction = EnableAction;
    exports.FocusAction = FocusAction;
    exports.MarkAsDirtyAction = MarkAsDirtyAction;
    exports.MarkAsPristineAction = MarkAsPristineAction;
    exports.MarkAsSubmittedAction = MarkAsSubmittedAction;
    exports.MarkAsTouchedAction = MarkAsTouchedAction;
    exports.MarkAsUnsubmittedAction = MarkAsUnsubmittedAction;
    exports.MarkAsUntouchedAction = MarkAsUntouchedAction;
    exports.MoveArrayControlAction = MoveArrayControlAction;
    exports.NGRX_FORM_VIEW_ADAPTER = NGRX_FORM_VIEW_ADAPTER;
    exports.NGRX_STATUS_CLASS_NAMES = NGRX_STATUS_CLASS_NAMES;
    exports.NgrxCheckboxViewAdapter = NgrxCheckboxViewAdapter;
    exports.NgrxDefaultViewAdapter = NgrxDefaultViewAdapter;
    exports.NgrxFallbackSelectOption = NgrxFallbackSelectOption;
    exports.NgrxFormControlDirective = NgrxFormControlDirective;
    exports.NgrxFormDirective = NgrxFormDirective;
    exports.NgrxFormsModule = NgrxFormsModule;
    exports.NgrxLocalFormControlDirective = NgrxLocalFormControlDirective;
    exports.NgrxLocalFormDirective = NgrxLocalFormDirective;
    exports.NgrxNumberViewAdapter = NgrxNumberViewAdapter;
    exports.NgrxRadioViewAdapter = NgrxRadioViewAdapter;
    exports.NgrxRangeViewAdapter = NgrxRangeViewAdapter;
    exports.NgrxSelectMultipleOption = NgrxSelectMultipleOption;
    exports.NgrxSelectMultipleViewAdapter = NgrxSelectMultipleViewAdapter;
    exports.NgrxSelectOption = NgrxSelectOption;
    exports.NgrxSelectViewAdapter = NgrxSelectViewAdapter;
    exports.NgrxStatusCssClassesDirective = NgrxStatusCssClassesDirective;
    exports.NgrxValueConverters = NgrxValueConverters;
    exports.RemoveArrayControlAction = RemoveArrayControlAction;
    exports.RemoveGroupControlAction = RemoveGroupControlAction;
    exports.ResetAction = ResetAction;
    exports.SetAsyncErrorAction = SetAsyncErrorAction;
    exports.SetErrorsAction = SetErrorsAction;
    exports.SetUserDefinedPropertyAction = SetUserDefinedPropertyAction;
    exports.SetValueAction = SetValueAction;
    exports.StartAsyncValidationAction = StartAsyncValidationAction;
    exports.SwapArrayControlAction = SwapArrayControlAction;
    exports.UnfocusAction = UnfocusAction;
    exports.addArrayControl = addArrayControl;
    exports.addGroupControl = addGroupControl;
    exports.box = box;
    exports.clearAsyncError = clearAsyncError;
    exports.compose = compose;
    exports.createFormArrayState = createFormArrayState;
    exports.createFormControlState = createFormControlState;
    exports.createFormGroupState = createFormGroupState;
    exports.createFormStateReducerWithUpdate = createFormStateReducerWithUpdate;
    exports.disable = disable;
    exports.enable = enable;
    exports.focus = focus;
    exports.formArrayReducer = formArrayReducer;
    exports.formControlReducer = formControlReducer;
    exports.formGroupReducer = formGroupReducer;
    exports.formStateReducer = formStateReducer;
    exports.isArrayState = isArrayState;
    exports.isBoxed = isBoxed;
    exports.isGroupState = isGroupState;
    exports.isNgrxFormsAction = isNgrxFormsAction;
    exports.markAsDirty = markAsDirty;
    exports.markAsPristine = markAsPristine;
    exports.markAsSubmitted = markAsSubmitted;
    exports.markAsTouched = markAsTouched;
    exports.markAsUnsubmitted = markAsUnsubmitted;
    exports.markAsUntouched = markAsUntouched;
    exports.moveArrayControl = moveArrayControl;
    exports.onNgrxForms = onNgrxForms;
    exports.onNgrxFormsAction = onNgrxFormsAction;
    exports.removeArrayControl = removeArrayControl;
    exports.removeGroupControl = removeGroupControl;
    exports.reset = reset;
    exports.setAsyncError = setAsyncError;
    exports.setErrors = setErrors;
    exports.setUserDefinedProperty = setUserDefinedProperty;
    exports.setValue = setValue;
    exports.startAsyncValidation = startAsyncValidation;
    exports.swapArrayControl = swapArrayControl;
    exports.unbox = unbox;
    exports.unfocus = unfocus;
    exports.updateArray = updateArray;
    exports.updateArrayWithFilter = updateArrayWithFilter;
    exports.updateGroup = updateGroup;
    exports.updateRecursive = updateRecursive;
    exports.validate = validate;
    exports.wrapReducerWithFormStateUpdate = wrapReducerWithFormStateUpdate;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=ngrx-forms.umd.js.map
